;; Analyzed by ClojureScript 1.7.228
{:use-macros {error clojure.core.matrix.macros}, :excludes #{clone}, :name clojure.core.matrix.protocols, :imports nil, :requires {clojure.core.matrix.utils clojure.core.matrix.utils, mops clojure.core.matrix.impl.mathsops, clojure.core.matrix.impl.mathsops clojure.core.matrix.impl.mathsops}, :uses {same-shape-object? clojure.core.matrix.utils}, :defs {sparse {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 201, :column 4, :end-line 201, :end-column 10, :protocol clojure.core.matrix.protocols/PSparse, :doc "Attempts to make array into a sparse format. Must return the same array unchanged if not possible.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PSparse, :name clojure.core.matrix.protocols/sparse, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 194, :end-line 201, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Attempts to make array into a sparse format. Must return the same array unchanged if not possible."}, PIndicesSetting {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1096, :column 14, :end-line 1096, :end-column 29, :doc "Protocol for setting elements of an array at the specified indices", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {set-indices [[a indices values]], set-indices! [[a indices values]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PIndicesSetting, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :column 1, :line 1096, :protocol-info {:methods {set-indices [[a indices values]], set-indices! [[a indices values]]}}, :info nil, :end-line 1096, :impls #{}, :doc "Protocol for setting elements of an array at the specified indices", :jsdoc ("@interface")}, element-clamp {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 937, :column 4, :end-line 937, :end-column 17, :protocol clojure.core.matrix.protocols/PElementMinMax, :doc "Returns a matrix where the elements are clamped to be within lower and\n    upper bounds specified by a and b, respectively.", :arglists (quote ([m a b]))}, :protocol clojure.core.matrix.protocols/PElementMinMax, :name clojure.core.matrix.protocols/element-clamp, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([m a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 932, :end-line 937, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m a b])), :doc "Returns a matrix where the elements are clamped to be within lower and\n    upper bounds specified by a and b, respectively."}, sqrt! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 921, :column 4, :end-line 921, :end-column 9, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/sqrt!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 921, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, select-columns {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1173, :column 4, :end-line 1173, :end-column 18, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :doc "Produces a new dataset with the columns in the specified order", :arglists (quote ([ds cols]))}, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :name clojure.core.matrix.protocols/select-columns, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([ds cols]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1170, :end-line 1173, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ds cols])), :doc "Produces a new dataset with the columns in the specified order"}, relu! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 846, :column 4, :end-line 846, :end-column 9, :protocol clojure.core.matrix.protocols/PReLUMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PReLUMutable, :name clojure.core.matrix.protocols/relu!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 844, :end-line 846, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, rename-columns {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1179, :column 4, :end-line 1179, :end-column 18, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :doc "Renames columns based on map of old new column name pairs", :arglists (quote ([ds col-map]))}, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :name clojure.core.matrix.protocols/rename-columns, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([ds col-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1170, :end-line 1179, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ds col-map])), :doc "Renames columns based on map of old new column name pairs"}, is-mutable? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 105, :column 4, :end-line 105, :end-column 15, :protocol clojure.core.matrix.protocols/PIndexedSetting, :doc "Returns true if the matrix is mutable and therefore supports direct mutable operations, e.g. add!", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PIndexedSetting, :name clojure.core.matrix.protocols/is-mutable?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 105, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if the matrix is mutable and therefore supports direct mutable operations, e.g. add!"}, PVectorisable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 775, :column 14, :end-line 775, :end-column 27, :doc "Protocol to return an array as a flattened vector of all elements.\n   Implementations are encouraged to avoid taking a full copy of all data\n   (e.g. by using structural sharing or views).", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {to-vector [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PVectorisable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 27, :column 1, :line 775, :protocol-info {:methods {to-vector [[m]]}}, :info nil, :end-line 775, :impls #{}, :doc "Protocol to return an array as a flattened vector of all elements.\n   Implementations are encouraged to avoid taking a full copy of all data\n   (e.g. by using structural sharing or views).", :jsdoc ("@interface")}, dense {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 212, :column 4, :end-line 212, :end-column 9, :protocol clojure.core.matrix.protocols/PDense, :doc "Attempts to make array into a dense format. Must return the same array unchanged if not possible.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PDense, :name clojure.core.matrix.protocols/dense, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 209, :end-line 212, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Attempts to make array into a dense format. Must return the same array unchanged if not possible."}, sparse-coerce {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 200, :column 4, :end-line 200, :end-column 17, :protocol clojure.core.matrix.protocols/PSparse, :doc "Attempts to coerce data to a sparse array of implementation m. May return nil if not supported", :arglists (quote ([m data]))}, :protocol clojure.core.matrix.protocols/PSparse, :name clojure.core.matrix.protocols/sparse-coerce, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([m data]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 194, :end-line 200, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m data])), :doc "Attempts to coerce data to a sparse array of implementation m. May return nil if not supported"}, PSoftplus {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 832, :column 14, :end-line 832, :end-column 23, :doc "Protocol to support element-wise softplus function on a numerical array.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {softplus [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSoftplus, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :column 1, :line 832, :protocol-info {:methods {softplus [[m]]}}, :info nil, :end-line 832, :impls #{}, :doc "Protocol to support element-wise softplus function on a numerical array.", :jsdoc ("@interface")}, PSpecialisedConstructors {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 244, :column 14, :end-line 244, :end-column 38, :doc "Protocol for construction of special matrices.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {identity-matrix [[m dims]], diagonal-matrix [[m diagonal-values]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSpecialisedConstructors, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 38, :column 1, :line 244, :protocol-info {:methods {identity-matrix [[m dims]], diagonal-matrix [[m diagonal-values]]}}, :info nil, :end-line 244, :impls #{}, :doc "Protocol for construction of special matrices.", :jsdoc ("@interface")}, PMatrixMutableScaling {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 610, :column 14, :end-line 610, :end-column 35, :doc "Protocol to support mutable array scaling by scalar values.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {scale! [[m factor]], pre-scale! [[m factor]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixMutableScaling, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 35, :column 1, :line 610, :protocol-info {:methods {scale! [[m factor]], pre-scale! [[m factor]]}}, :info nil, :end-line 610, :impls #{}, :doc "Protocol to support mutable array scaling by scalar values.", :jsdoc ("@interface")}, validate-shape {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 163, :column 4, :end-line 163, :end-column 18, :protocol clojure.core.matrix.protocols/PValidateShape, :doc "Returns the shape of the array, performing validation and throwing an error if the shape is inconsistent", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PValidateShape, :name clojure.core.matrix.protocols/validate-shape, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 160, :end-line 163, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the shape of the array, performing validation and throwing an error if the shape is inconsistent"}, rotate-all {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 703, :column 4, :end-line 703, :end-column 14, :protocol clojure.core.matrix.protocols/PRotateAll, :doc nil, :arglists (quote ([m shifts]))}, :protocol clojure.core.matrix.protocols/PRotateAll, :name clojure.core.matrix.protocols/rotate-all, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m shifts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 699, :end-line 703, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m shifts])), :doc nil}, get-slice {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 345, :column 4, :end-line 345, :end-column 13, :protocol clojure.core.matrix.protocols/PMatrixSlices, :doc "Gets a slice of an array along a specified dimension with the given index.", :arglists (quote ([m dimension i]))}, :protocol clojure.core.matrix.protocols/PMatrixSlices, :name clojure.core.matrix.protocols/get-slice, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m dimension i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 336, :end-line 345, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m dimension i])), :doc "Gets a slice of an array along a specified dimension with the given index."}, PColumnNames {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1124, :column 14, :end-line 1124, :end-column 26, :doc "Protocol for arrays supporting labelled columns. This is a specialisation of label functionality\n   intended for use by datasets, the key difference is that column-names should always select the\n   last dimension.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {column-name [[m column]], column-names [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PColumnNames, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 26, :column 1, :line 1124, :protocol-info {:methods {column-name [[m column]], column-names [[m]]}}, :info nil, :end-line 1124, :impls #{}, :doc "Protocol for arrays supporting labelled columns. This is a specialisation of label functionality\n   intended for use by datasets, the key difference is that column-names should always select the\n   last dimension.", :jsdoc ("@interface")}, numerical? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 739, :column 4, :end-line 739, :end-column 14, :protocol clojure.core.matrix.protocols/PNumerical, :doc "Returns true if the array is numerical.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PNumerical, :name clojure.core.matrix.protocols/numerical?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 736, :end-line 739, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if the array is numerical."}, PVectorCross {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 760, :column 14, :end-line 760, :end-column 26, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {cross-product [[a b]], cross-product! [[a b]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PVectorCross, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 26, :column 1, :line 760, :protocol-info {:methods {cross-product [[a b]], cross-product! [[a b]]}}, :info nil, :end-line 760, :impls #{}, :doc nil, :jsdoc ("@interface")}, PNorm {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1134, :column 14, :end-line 1134, :end-column 19, :doc "Protocol for matrix and vector norms", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {norm [[m p]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PNorm, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :column 1, :line 1134, :protocol-info {:methods {norm [[m p]]}}, :info nil, :end-line 1134, :impls #{}, :doc "Protocol for matrix and vector norms", :jsdoc ("@interface")}, PNewSparseArray {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 428, :column 14, :end-line 428, :end-column 29, :doc "Protocol for constructing sparse arrays. Should return nil if the sparse array shape is not supported.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {new-sparse-array [[m shape]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PNewSparseArray, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :column 1, :line 428, :protocol-info {:methods {new-sparse-array [[m shape]]}}, :info nil, :end-line 428, :impls #{}, :doc "Protocol for constructing sparse arrays. Should return nil if the sparse array shape is not supported.", :jsdoc ("@interface")}, distance {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 767, :column 4, :end-line 767, :end-column 12, :protocol clojure.core.matrix.protocols/PVectorDistance, :doc "Euclidean distance of two vectors.", :arglists (quote ([a b]))}, :protocol clojure.core.matrix.protocols/PVectorDistance, :name clojure.core.matrix.protocols/distance, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 12, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 766, :end-line 767, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :doc "Euclidean distance of two vectors."}, PSparseArray {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 421, :column 14, :end-line 421, :end-column 26, :doc "Protocol for determining if an array is in a sparse format. It is up to the implementation to define\n   its own sparse formats, but in general the intention should be that a sparse array uses significantly\n   less storage than an equivalent dense array, assuming a high proportion of zero values in the array.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {is-sparse? [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSparseArray, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 26, :column 1, :line 421, :protocol-info {:methods {is-sparse? [[m]]}}, :info nil, :end-line 421, :impls #{}, :doc "Protocol for determining if an array is in a sparse format. It is up to the implementation to define\n   its own sparse formats, but in general the intention should be that a sparse array uses significantly\n   less storage than an equivalent dense array, assuming a high proportion of zero values in the array.", :jsdoc ("@interface")}, diagonal? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1045, :column 4, :end-line 1045, :end-column 13, :protocol clojure.core.matrix.protocols/PMatrixTypes, :doc "Returns true if the matrix is diagonal, i.e. zero everywhere except the main diagonal", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixTypes, :name clojure.core.matrix.protocols/diagonal?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1044, :end-line 1045, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if the matrix is diagonal, i.e. zero everywhere except the main diagonal"}, add-inner-product! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 649, :column 4, :end-line 649, :end-column 22, :protocol clojure.core.matrix.protocols/PAddInnerProductMutable, :doc "Adds the inner product of a, b and an optional scalar factor to m", :arglists (quote ([m a b] [m a b factor])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m a b] [m a b factor]), :arglists ([m a b] [m a b factor]), :arglists-meta (nil nil)}}, :protocol clojure.core.matrix.protocols/PAddInnerProductMutable, :name clojure.core.matrix.protocols/add-inner-product!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 22, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m a b] [m a b factor]), :arglists ([m a b] [m a b factor]), :arglists-meta (nil nil)}, :method-params ([m a b] [m a b factor]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 645, :end-line 649, :max-fixed-arity 4, :fn-var true, :arglists ([m a b] [m a b factor]), :doc "Adds the inner product of a, b and an optional scalar factor to m"}, positive-semidefinite? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1049, :column 4, :end-line 1049, :end-column 26, :protocol clojure.core.matrix.protocols/PMatrixTypes, :doc "Returns true if the matrix is positive semidefinite", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixTypes, :name clojure.core.matrix.protocols/positive-semidefinite?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 26, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1044, :end-line 1049, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if the matrix is positive semidefinite"}, PMapIndexed {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1010, :column 14, :end-line 1010, :end-column 25, :doc "Protocol for map-indexed operation on matrices", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {element-map-indexed [[m f] [m f a] [m f a more]], element-map-indexed! [[m f] [m f a] [m f a more]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMapIndexed, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :column 1, :line 1010, :protocol-info {:methods {element-map-indexed [[m f] [m f a] [m f a more]], element-map-indexed! [[m f] [m f a] [m f a more]]}}, :info nil, :end-line 1010, :impls #{}, :doc "Protocol for map-indexed operation on matrices", :jsdoc ("@interface")}, PSoftplusMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 836, :column 14, :end-line 836, :end-column 30, :doc "Protocol to support mutable element-wise softplus function on a numerical array.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {softplus! [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSoftplusMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 30, :column 1, :line 836, :protocol-info {:methods {softplus! [[m]]}}, :info nil, :end-line 836, :impls #{}, :doc "Protocol to support mutable element-wise softplus function on a numerical array.", :jsdoc ("@interface")}, identity-matrix? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1034, :column 4, :end-line 1034, :end-column 20, :protocol clojure.core.matrix.protocols/PMatrixPredicates, :doc "Returns true if the matrix m is an identity matrix", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixPredicates, :name clojure.core.matrix.protocols/identity-matrix?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1032, :end-line 1034, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if the matrix m is an identity matrix"}, pre-scale! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 613, :column 4, :end-line 613, :end-column 14, :protocol clojure.core.matrix.protocols/PMatrixMutableScaling, :doc nil, :arglists (quote ([m factor]))}, :protocol clojure.core.matrix.protocols/PMatrixMutableScaling, :name clojure.core.matrix.protocols/pre-scale!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m factor]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 610, :end-line 613, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m factor])), :doc nil}, to-radians {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 901, :column 4, :end-line 901, :end-column 14, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/to-radians, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 901, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PMatrixCloning {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 121, :column 14, :end-line 121, :end-column 28, :doc "Protocol for cloning a matrix value. The new clone must be mutable if the original\n   matrix is mutable, i.e. mutating the clone must not affect the original. The copy should be shallow, if applicable.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {clone [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixCloning, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 121, :protocol-info {:methods {clone [[m]]}}, :info nil, :end-line 121, :impls #{}, :doc "Protocol for cloning a matrix value. The new clone must be mutable if the original\n   matrix is mutable, i.e. mutating the clone must not affect the original. The copy should be shallow, if applicable.", :jsdoc ("@interface")}, new-scalar-array {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 222, :column 4, :end-line 222, :end-column 20, :protocol clojure.core.matrix.protocols/PZeroDimensionConstruction, :doc "Construct a new zero-dimensional array with the specified scalar value (zero if not specified)", :arglists (quote ([m] [m value])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([m] [m value]), :arglists ([m] [m value]), :arglists-meta (nil nil)}}, :protocol clojure.core.matrix.protocols/PZeroDimensionConstruction, :name clojure.core.matrix.protocols/new-scalar-array, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([m] [m value]), :arglists ([m] [m value]), :arglists-meta (nil nil)}, :method-params ([m] [m value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 221, :end-line 222, :max-fixed-arity 2, :fn-var true, :arglists ([m] [m value]), :doc "Construct a new zero-dimensional array with the specified scalar value (zero if not specified)"}, set-1d! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 117, :column 4, :end-line 117, :end-column 11, :protocol clojure.core.matrix.protocols/PIndexedSettingMutable, :doc nil, :arglists (quote ([m row v]))}, :protocol clojure.core.matrix.protocols/PIndexedSettingMutable, :name clojure.core.matrix.protocols/set-1d!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m row v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 114, :end-line 117, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m row v])), :doc nil}, PReLUMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 844, :column 14, :end-line 844, :end-column 26, :doc "Protocol to support mutable element-wise relu function on a numerical array.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {relu! [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PReLUMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 26, :column 1, :line 844, :protocol-info {:methods {relu! [[m]]}}, :info nil, :end-line 844, :impls #{}, :doc "Protocol to support mutable element-wise relu function on a numerical array.", :jsdoc ("@interface")}, PMatrixScaling {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 598, :column 14, :end-line 598, :end-column 28, :doc "Protocol to support numerical array scaling by scalar values. Provided because array classes may have\n   efficient specialised scaling operaions.\n\n   Works according the the default definition of multiplication for the matrix class\n   (usually numerical, i.e. equivalent to clojure.core/+)", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {scale [[m constant]], pre-scale [[m constant]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixScaling, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 598, :protocol-info {:methods {scale [[m constant]], pre-scale [[m constant]]}}, :info nil, :end-line 598, :impls #{}, :doc "Protocol to support numerical array scaling by scalar values. Provided because array classes may have\n   efficient specialised scaling operaions.\n\n   Works according the the default definition of multiplication for the matrix class\n   (usually numerical, i.e. equivalent to clojure.core/+)", :jsdoc ("@interface")}, to-map {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1176, :column 4, :end-line 1176, :end-column 10, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :doc "Returns map of columns with associated list of values", :arglists (quote ([ds]))}, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :name clojure.core.matrix.protocols/to-map, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([ds]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1170, :end-line 1176, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ds])), :doc "Returns map of columns with associated list of values"}, orthogonal? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1050, :column 4, :end-line 1050, :end-column 15, :protocol clojure.core.matrix.protocols/PMatrixTypes, :doc "Returns true if the matrix is orthogonal", :arglists (quote ([m eps]))}, :protocol clojure.core.matrix.protocols/PMatrixTypes, :name clojure.core.matrix.protocols/orthogonal?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m eps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1044, :end-line 1050, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m eps])), :doc "Returns true if the matrix is orthogonal"}, PMatrixSubComponents {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 415, :column 14, :end-line 415, :end-column 34, :doc "Protocol for picking out subsections of a 2D matrix. Should return a mutable view if possible.\n   The default implementation creates a new vector containing the diagonal values.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {main-diagonal [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixSubComponents, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 34, :column 1, :line 415, :protocol-info {:methods {main-diagonal [[m]]}}, :info nil, :end-line 415, :impls #{}, :doc "Protocol for picking out subsections of a 2D matrix. Should return a mutable view if possible.\n   The default implementation creates a new vector containing the diagonal values.", :jsdoc ("@interface")}, PIndexImplementation {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1107, :column 14, :end-line 1107, :end-column 34, :doc "Protocol for determining if an object is a valid index. Implementations may implement this protocol to support their own index types.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {index? [[m]], index-to-longs [[m]], index-to-ints [[m]], index-from-longs [[m xs]], index-from-ints [[m xs]], index-coerce [[m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PIndexImplementation, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 34, :column 1, :line 1107, :protocol-info {:methods {index? [[m]], index-to-longs [[m]], index-to-ints [[m]], index-from-longs [[m xs]], index-from-ints [[m xs]], index-coerce [[m a]]}}, :info nil, :end-line 1107, :impls #{}, :doc "Protocol for determining if an object is a valid index. Implementations may implement this protocol to support their own index types.", :jsdoc ("@interface")}, PAddScaledProduct {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 539, :column 14, :end-line 539, :end-column 31, :doc "Protocol for add-product operation.\n\n   Intended to support optimised implementations for result = m + a * b * factor", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {add-scaled-product [[m a b factor]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PAddScaledProduct, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 31, :column 1, :line 539, :protocol-info {:methods {add-scaled-product [[m a b factor]]}}, :info nil, :end-line 539, :impls #{}, :doc "Protocol for add-product operation.\n\n   Intended to support optimised implementations for result = m + a * b * factor", :jsdoc ("@interface")}, negate {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 800, :column 4, :end-line 800, :end-column 10, :protocol clojure.core.matrix.protocols/PNegation, :doc "Returns a new numerical array with all elements negated.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PNegation, :name clojure.core.matrix.protocols/negate, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 799, :end-line 800, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns a new numerical array with all elements negated."}, set-2d! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 118, :column 4, :end-line 118, :end-column 11, :protocol clojure.core.matrix.protocols/PIndexedSettingMutable, :doc nil, :arglists (quote ([m row column v]))}, :protocol clojure.core.matrix.protocols/PIndexedSettingMutable, :name clojure.core.matrix.protocols/set-2d!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m row column v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 114, :end-line 118, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m row column v])), :doc nil}, PDense {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 209, :column 14, :end-line 209, :end-column 20, :doc "Protocol for constructing a dense array from the given data.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {dense-coerce [[m data]], dense [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PDense, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :column 1, :line 209, :protocol-info {:methods {dense-coerce [[m data]], dense [[m]]}}, :info nil, :end-line 209, :impls #{}, :doc "Protocol for constructing a dense array from the given data.", :jsdoc ("@interface")}, PPermutationMatrix {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 253, :column 14, :end-line 253, :end-column 32, :doc "Protocol for construction of a permutation matrix.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {permutation-matrix [[m permutation]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PPermutationMatrix, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 32, :column 1, :line 253, :protocol-info {:methods {permutation-matrix [[m permutation]]}}, :info nil, :end-line 253, :impls #{}, :doc "Protocol for construction of a permutation matrix.", :jsdoc ("@interface")}, asin! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 907, :column 4, :end-line 907, :end-column 9, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/asin!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 907, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PImmutableMatrixConstruction {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 214, :column 14, :end-line 214, :end-column 42, :doc "Protocol for creating an immutable copy of a matrix. If implemented, must return a fully immutable\n   copy of the given matrix.\n\n   The default implementation will attempt to choose a suitable immutable matrix implementation.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {immutable-matrix [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PImmutableMatrixConstruction, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 42, :column 1, :line 214, :protocol-info {:methods {immutable-matrix [[m]]}}, :info nil, :end-line 214, :impls #{}, :doc "Protocol for creating an immutable copy of a matrix. If implemented, must return a fully immutable\n   copy of the given matrix.\n\n   The default implementation will attempt to choose a suitable immutable matrix implementation.", :jsdoc ("@interface")}, get-column {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 341, :column 4, :end-line 341, :end-column 14, :protocol clojure.core.matrix.protocols/PMatrixSlices, :doc "Gets a column of a matrix with the given row index.", :arglists (quote ([m i]))}, :protocol clojure.core.matrix.protocols/PMatrixSlices, :name clojure.core.matrix.protocols/get-column, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 336, :end-line 341, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m i])), :doc "Gets a column of a matrix with the given row index."}, cos! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 911, :column 4, :end-line 911, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/cos!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 911, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, svd {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1152, :column 4, :end-line 1152, :end-column 7, :protocol clojure.core.matrix.protocols/PSVDDecomposition, :doc nil, :arglists (quote ([m options]))}, :protocol clojure.core.matrix.protocols/PSVDDecomposition, :name clojure.core.matrix.protocols/svd, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 7, :method-params ([m options]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1150, :end-line 1152, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m options])), :doc nil}, ceil! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 910, :column 4, :end-line 910, :end-column 9, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/ceil!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 910, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, POrder {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 720, :column 14, :end-line 720, :end-column 20, :doc "Protocol for matrix reorder.\n\n   By default, re-orders along the first (major) dimension, but may reorder along any dimension by\n   specifiying the dimension argument.\n\n   Indicies can be any seqable object containing the indices along the specified dimension to select.\n   An index can be selected multiple times (which created repreated slices), or not at all (which excludes\n   the slice from the result).\n\n   Some implementation may implement re-ordering using lightweight or mutable views over the original array\n   data.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {order [[m indices] [m dimension indices]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/POrder, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :column 1, :line 720, :protocol-info {:methods {order [[m indices] [m dimension indices]]}}, :info nil, :end-line 720, :impls #{}, :doc "Protocol for matrix reorder.\n\n   By default, re-orders along the first (major) dimension, but may reorder along any dimension by\n   specifiying the dimension argument.\n\n   Indicies can be any seqable object containing the indices along the specified dimension to select.\n   An index can be selected multiple times (which created repreated slices), or not at all (which excludes\n   the slice from the result).\n\n   Some implementation may implement re-ordering using lightweight or mutable views over the original array\n   data.", :jsdoc ("@interface")}, element-map {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 990, :column 4, :end-line 990, :end-column 15, :protocol clojure.core.matrix.protocols/PFunctionalOperations, :doc "Maps f over all elements of m (and optionally other matrices), returning a new matrix.\n     f is expected to produce elements of a type supported by the implementation of m - failure\n     to do so may cause an error.", :arglists (quote ([m f] [m f a] [m f a more])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m f] [m f a] [m f a more]), :arglists ([m f] [m f a] [m f a more]), :arglists-meta (nil nil nil)}}, :protocol clojure.core.matrix.protocols/PFunctionalOperations, :name clojure.core.matrix.protocols/element-map, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m f] [m f a] [m f a more]), :arglists ([m f] [m f a] [m f a more]), :arglists-meta (nil nil nil)}, :method-params ([m f] [m f a] [m f a more]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 983, :end-line 990, :max-fixed-arity 4, :fn-var true, :arglists ([m f] [m f a] [m f a more]), :doc "Maps f over all elements of m (and optionally other matrices), returning a new matrix.\n     f is expected to produce elements of a type supported by the implementation of m - failure\n     to do so may cause an error."}, log {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 891, :column 4, :end-line 891, :end-column 7, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/log, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 7, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 891, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, column-name {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1128, :column 4, :end-line 1128, :end-column 15, :protocol clojure.core.matrix.protocols/PColumnNames, :doc "Returns the label at a specific column", :arglists (quote ([m column]))}, :protocol clojure.core.matrix.protocols/PColumnNames, :name clojure.core.matrix.protocols/column-name, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m column]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1124, :end-line 1128, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m column])), :doc "Returns the label at a specific column"}, PSelectView {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1080, :column 14, :end-line 1080, :end-column 25, :doc "Protocol for the sel function. Like PSelect, but guarantees an mutable view.\n\n   If not supported by the implementation, may return nil to indicate that a default mutable view\n   should be created.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {select-view [[a args]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSelectView, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :column 1, :line 1080, :protocol-info {:methods {select-view [[a args]]}}, :info nil, :end-line 1080, :impls #{}, :doc "Protocol for the sel function. Like PSelect, but guarantees an mutable view.\n\n   If not supported by the implementation, may return nil to indicate that a default mutable view\n   should be created.", :jsdoc ("@interface")}, acos {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 882, :column 4, :end-line 882, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/acos, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 882, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, element-multiply {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 518, :column 4, :end-line 518, :end-column 20, :protocol clojure.core.matrix.protocols/PMatrixMultiply, :doc nil, :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PMatrixMultiply, :name clojure.core.matrix.protocols/element-multiply, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 512, :end-line 518, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc nil}, to-degrees {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 900, :column 4, :end-line 900, :end-column 14, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/to-degrees, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 900, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PPack {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 319, :column 14, :end-line 319, :end-column 19, :doc "Protocol to efficiently pack an array, according to the most efficient representation for a given\n   implementation.\n\n   Definition of pack is up to the implementation to interpret, but the general rules are:\n   1. Must not change the value of the array for comparison purposes\n   2. Must not change the shape of the array\n   3. May preserve sparse representation\n   4. Should convert to most efficient format for common operations (e.g. mget, inner-product)", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {pack [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PPack, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :column 1, :line 319, :protocol-info {:methods {pack [[m]]}}, :info nil, :end-line 319, :impls #{}, :doc "Protocol to efficiently pack an array, according to the most efficient representation for a given\n   implementation.\n\n   Definition of pack is up to the implementation to interpret, but the general rules are:\n   1. Must not change the value of the array for comparison purposes\n   2. Must not change the shape of the array\n   3. May preserve sparse representation\n   4. Should convert to most efficient format for common operations (e.g. mget, inner-product)", :jsdoc ("@interface")}, PConversion {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 305, :column 14, :end-line 305, :end-column 25, :doc "Protocol to allow conversion to Clojure-friendly vector format. Optional for implementers,\n   however providing an efficient implementation is strongly encouraged to enable fast interop\n   with Clojure vectors.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {convert-to-nested-vectors [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PConversion, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :column 1, :line 305, :protocol-info {:methods {convert-to-nested-vectors [[m]]}}, :info nil, :end-line 305, :impls #{}, :doc "Protocol to allow conversion to Clojure-friendly vector format. Optional for implementers,\n   however providing an efficient implementation is strongly encouraged to enable fast interop\n   with Clojure vectors.", :jsdoc ("@interface")}, pack {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 328, :column 4, :end-line 328, :end-column 8, :protocol clojure.core.matrix.protocols/PPack, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PPack, :name clojure.core.matrix.protocols/pack, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 319, :end-line 328, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, floor {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 890, :column 4, :end-line 890, :end-column 9, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/floor, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 890, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PZeroDimensionSet {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 240, :column 14, :end-line 240, :end-column 31, :doc "Protocol for setting the scalar value in zero-dimensional arrays.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {set-0d [[m value]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PZeroDimensionSet, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 31, :column 1, :line 240, :protocol-info {:methods {set-0d [[m value]]}}, :info nil, :end-line 240, :impls #{}, :doc "Protocol for setting the scalar value in zero-dimensional arrays.", :jsdoc ("@interface")}, PLeastSquares {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1162, :column 14, :end-line 1162, :end-column 27, :doc "Protocol for computing least-square solution to a linear matrix equation", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {least-squares [[a b]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PLeastSquares, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 27, :column 1, :line 1162, :protocol-info {:methods {least-squares [[a b]]}}, :info nil, :end-line 1162, :impls #{}, :doc "Protocol for computing least-square solution to a linear matrix equation", :jsdoc ("@interface")}, as-vector {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 771, :column 4, :end-line 771, :end-column 13, :protocol clojure.core.matrix.protocols/PVectorView, :doc "Returns a view of an array as a single flattened vector. May return the vector itself\n     if it is already a 1D vector.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PVectorView, :name clojure.core.matrix.protocols/as-vector, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 770, :end-line 771, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns a view of an array as a single flattened vector. May return the vector itself\n     if it is already a 1D vector."}, matrix-multiply! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 586, :column 4, :end-line 586, :end-column 20, :protocol clojure.core.matrix.protocols/PMatrixMultiplyMutable, :doc nil, :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PMatrixMultiplyMutable, :name clojure.core.matrix.protocols/matrix-multiply!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 584, :end-line 586, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc nil}, PExponent {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 813, :column 14, :end-line 813, :end-column 23, :doc "Protocol to support the 'pow' function. Should raise every element of a matrix to a\n   given exponent. Default implementation uses Java's Math/pow function which is appropriate for\n   double values: arrays supporting arbitrary precision numbers or complex types will need to\n   provide their own implementation.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {element-pow [[m exponent]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PExponent, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :column 1, :line 813, :protocol-info {:methods {element-pow [[m exponent]]}}, :info nil, :end-line 813, :impls #{}, :doc "Protocol to support the 'pow' function. Should raise every element of a matrix to a\n   given exponent. Default implementation uses Java's Math/pow function which is appropriate for\n   double values: arrays supporting arbitrary precision numbers or complex types will need to\n   provide their own implementation.", :jsdoc ("@interface")}, PSVDDecomposition {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1150, :column 14, :end-line 1150, :end-column 31, :doc "Protocol for SVD decomposition", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {svd [[m options]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSVDDecomposition, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 31, :column 1, :line 1150, :protocol-info {:methods {svd [[m options]]}}, :info nil, :end-line 1150, :impls #{}, :doc "Protocol for SVD decomposition", :jsdoc ("@interface")}, element-le {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 959, :column 4, :end-line 959, :end-column 14, :protocol clojure.core.matrix.protocols/PCompare, :doc "Return a binary array or matrix where elements of m less-than-or-equal\n    to a are  represented by 1 and elements greater-than a are represented as 0.", :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PCompare, :name clojure.core.matrix.protocols/element-le, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 941, :end-line 959, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc "Return a binary array or matrix where elements of m less-than-or-equal\n    to a are  represented by 1 and elements greater-than a are represented as 0."}, PSummable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 808, :column 14, :end-line 808, :end-column 23, :doc "Protocol to support the summing of all elements in an array.\n   The array must hold numeric values only, or an exception will be thrown.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {element-sum [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSummable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :column 1, :line 808, :protocol-info {:methods {element-sum [[m]]}}, :info nil, :end-line 808, :impls #{}, :doc "Protocol to support the summing of all elements in an array.\n   The array must hold numeric values only, or an exception will be thrown.", :jsdoc ("@interface")}, identity-matrix {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 246, :column 4, :end-line 246, :end-column 19, :protocol clojure.core.matrix.protocols/PSpecialisedConstructors, :doc "Create a 2D identity matrix with the given number of dimensions", :arglists (quote ([m dims]))}, :protocol clojure.core.matrix.protocols/PSpecialisedConstructors, :name clojure.core.matrix.protocols/identity-matrix, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([m dims]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 244, :end-line 246, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m dims])), :doc "Create a 2D identity matrix with the given number of dimensions"}, set-indices {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1098, :column 4, :end-line 1098, :end-column 15, :protocol clojure.core.matrix.protocols/PIndicesSetting, :doc "sets the elements from a at indices to values", :arglists (quote ([a indices values]))}, :protocol clojure.core.matrix.protocols/PIndicesSetting, :name clojure.core.matrix.protocols/set-indices, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([a indices values]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1096, :end-line 1098, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a indices values])), :doc "sets the elements from a at indices to values"}, broadcast-compatible {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1231, :column 7, :end-line 1231, :end-column 27, :arglists (quote ([a b])), :doc "Broadcasts two matrices into identical shapes, coercing to the type of the first matrix.\n   Intended to prepare for elementwise operations.\n   Returns a vector containing the two broadcasted matrices.\n   Throws an error if not possible."}, :name clojure.core.matrix.protocols/broadcast-compatible, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 27, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1231, :end-line 1231, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :doc "Broadcasts two matrices into identical shapes, coercing to the type of the first matrix.\n   Intended to prepare for elementwise operations.\n   Returns a vector containing the two broadcasted matrices.\n   Throws an error if not possible."}, index? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1109, :column 4, :end-line 1109, :end-column 10, :protocol clojure.core.matrix.protocols/PIndexImplementation, :doc "Returns true if the argument is a valid index, false otherwise", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PIndexImplementation, :name clojure.core.matrix.protocols/index?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1107, :end-line 1109, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if the argument is a valid index, false otherwise"}, tanh {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 899, :column 4, :end-line 899, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/tanh, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 899, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, join {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 401, :column 4, :end-line 401, :end-column 8, :protocol clojure.core.matrix.protocols/PSliceJoin, :doc "Concatenates a to m, along the major slice dimension", :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PSliceJoin, :name clojure.core.matrix.protocols/join, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 399, :end-line 401, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc "Concatenates a to m, along the major slice dimension"}, add-scaled-product {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 543, :column 4, :end-line 543, :end-column 22, :protocol clojure.core.matrix.protocols/PAddScaledProduct, :doc "Adds the elementwise product of a, b and a scalar factor to m", :arglists (quote ([m a b factor]))}, :protocol clojure.core.matrix.protocols/PAddScaledProduct, :name clojure.core.matrix.protocols/add-scaled-product, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 22, :method-params ([m a b factor]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 539, :end-line 543, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m a b factor])), :doc "Adds the elementwise product of a, b and a scalar factor to m"}, matrix-sub {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 619, :column 4, :end-line 619, :end-column 14, :protocol clojure.core.matrix.protocols/PMatrixAdd, :doc nil, :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PMatrixAdd, :name clojure.core.matrix.protocols/matrix-sub, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 615, :end-line 619, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc nil}, dimension-count {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 85, :column 4, :end-line 85, :end-column 19, :protocol clojure.core.matrix.protocols/PDimensionInfo, :doc "Returns the size of a specific dimension. Must throw an exception if the array does not\n     have the specified dimension.", :arglists (quote ([m dimension-number]))}, :protocol clojure.core.matrix.protocols/PDimensionInfo, :name clojure.core.matrix.protocols/dimension-count, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([m dimension-number]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 71, :end-line 85, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m dimension-number])), :doc "Returns the size of a specific dimension. Must throw an exception if the array does not\n     have the specified dimension."}, PGenericValues {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1059, :column 14, :end-line 1059, :end-column 28, :doc "Protocol for returning the generic/default values of a matrix implementation", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {generic-zero [[m]], generic-one [[m]], generic-value [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PGenericValues, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 1059, :protocol-info {:methods {generic-zero [[m]], generic-one [[m]], generic-value [[m]]}}, :info nil, :end-line 1059, :impls #{}, :doc "Protocol for returning the generic/default values of a matrix implementation", :jsdoc ("@interface")}, implementation-key {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 39, :column 4, :end-line 39, :end-column 22, :protocol clojure.core.matrix.protocols/PImplementation, :doc "Returns a keyword representing this implementation, that can be used to request array instances or\n     look up implementation metadata etc.\n\n     Each implementation should have one unique key. Official mapping of implementation keywords is\n     maintained in the var clojure.core.matrix.implementations/KNOWN-IMPLEMENTATIONS.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PImplementation, :name clojure.core.matrix.protocols/implementation-key, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 22, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 36, :end-line 39, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns a keyword representing this implementation, that can be used to request array instances or\n     look up implementation metadata etc.\n\n     Each implementation should have one unique key. Official mapping of implementation keywords is\n     maintained in the var clojure.core.matrix.implementations/KNOWN-IMPLEMENTATIONS."}, atan! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 908, :column 4, :end-line 908, :end-column 9, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/atan!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 908, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, set-row {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 871, :column 4, :end-line 871, :end-column 11, :protocol clojure.core.matrix.protocols/PRowSetting, :doc nil, :arglists (quote ([m i row]))}, :protocol clojure.core.matrix.protocols/PRowSetting, :name clojure.core.matrix.protocols/set-row, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m i row]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 869, :end-line 871, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m i row])), :doc nil}, PReshaping {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 311, :column 14, :end-line 311, :end-column 24, :doc "Protocol to reshape matrices. Should support any new shape allowed by the implementation.\n   Must preserve row-major ordering of matrix elements.\n   If the original matrix is mutable, must return a new mutable copy of data.\n   If the new shape has less elements than the original shape, it is OK to truncate the remaining elements.\n   If the new shape requires more elements than the original shape, should throw an exception.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {reshape [[m shape]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PReshaping, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 311, :protocol-info {:methods {reshape [[m shape]]}}, :info nil, :end-line 311, :impls #{}, :doc "Protocol to reshape matrices. Should support any new shape allowed by the implementation.\n   Must preserve row-major ordering of matrix elements.\n   If the original matrix is mutable, must return a new mutable copy of data.\n   If the new shape has less elements than the original shape, it is OK to truncate the remaining elements.\n   If the new shape requires more elements than the original shape, should throw an exception.", :jsdoc ("@interface")}, PSliceJoin {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 399, :column 14, :end-line 399, :end-column 24, :doc "Protocol for concatenating / joining arrays.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {join [[m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSliceJoin, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 399, :protocol-info {:methods {join [[m a]]}}, :info nil, :end-line 399, :impls #{}, :doc "Protocol for concatenating / joining arrays.", :jsdoc ("@interface")}, PRotate {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 693, :column 14, :end-line 693, :end-column 21, :doc "Rotates an array along a specified dimension by the given number of places.\n\n   Rotating a dimension that does not exist has no effect on the array.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {rotate [[m dim places]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PRotate, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 21, :column 1, :line 693, :protocol-info {:methods {rotate [[m dim places]]}}, :info nil, :end-line 693, :impls #{}, :doc "Rotates an array along a specified dimension by the given number of places.\n\n   Rotating a dimension that does not exist has no effect on the array.", :jsdoc ("@interface")}, get-rows {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 350, :column 4, :end-line 350, :end-column 12, :protocol clojure.core.matrix.protocols/PMatrixRows, :doc "Returns the rows of a matrix, as a sequence", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixRows, :name clojure.core.matrix.protocols/get-rows, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 12, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 348, :end-line 350, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the rows of a matrix, as a sequence"}, element-ge {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 965, :column 4, :end-line 965, :end-column 14, :protocol clojure.core.matrix.protocols/PCompare, :doc "Return a binary array or matrix where elements of m greater-than-or-equal\n    to a are  represented by 1 and elements less than a are represented as 0.", :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PCompare, :name clojure.core.matrix.protocols/element-ge, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 941, :end-line 965, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc "Return a binary array or matrix where elements of m greater-than-or-equal\n    to a are  represented by 1 and elements less than a are represented as 0."}, PShift {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 705, :column 14, :end-line 705, :end-column 20, :doc "Rotates an array using the specified shifts for each dimension. Newly shifted in elements\n   should be filled with the default scalar value (usually zero).", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {shift [[m dim places]], shift-all [[m shifts]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PShift, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :column 1, :line 705, :protocol-info {:methods {shift [[m dim places]], shift-all [[m shifts]]}}, :info nil, :end-line 705, :impls #{}, :doc "Rotates an array using the specified shifts for each dimension. Newly shifted in elements\n   should be filled with the default scalar value (usually zero).", :jsdoc ("@interface")}, select {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1078, :column 4, :end-line 1078, :end-column 10, :protocol clojure.core.matrix.protocols/PSelect, :doc "selects all elements at indices which are in the cartesian product of args", :arglists (quote ([a args]))}, :protocol clojure.core.matrix.protocols/PSelect, :name clojure.core.matrix.protocols/select, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([a args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1075, :end-line 1078, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a args])), :doc "selects all elements at indices which are in the cartesian product of args"}, add-scaled! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 566, :column 4, :end-line 566, :end-column 15, :protocol clojure.core.matrix.protocols/PAddScaledMutable, :doc nil, :arglists (quote ([m a factor]))}, :protocol clojure.core.matrix.protocols/PAddScaledMutable, :name clojure.core.matrix.protocols/add-scaled!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m a factor]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 560, :end-line 566, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m a factor])), :doc nil}, PArrayMetrics {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 155, :column 14, :end-line 155, :end-column 27, :doc "Option protocol for quick determination of array matrics", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {nonzero-count [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PArrayMetrics, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 27, :column 1, :line 155, :protocol-info {:methods {nonzero-count [[m]]}}, :info nil, :end-line 155, :impls #{}, :doc "Option protocol for quick determination of array matrics", :jsdoc ("@interface")}, is-sparse? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 425, :column 4, :end-line 425, :end-column 14, :protocol clojure.core.matrix.protocols/PSparseArray, :doc "Returns true if the array is in a sparse format, as defined by the implementation.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PSparseArray, :name clojure.core.matrix.protocols/is-sparse?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 421, :end-line 425, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if the array is in a sparse format, as defined by the implementation."}, new-matrix {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 62, :column 4, :end-line 62, :end-column 14, :protocol clojure.core.matrix.protocols/PImplementation, :doc "Returns a new matrix (regular 2D matrix) with the given number of rows and columns, filled with numeric zero.", :arglists (quote ([m rows columns]))}, :protocol clojure.core.matrix.protocols/PImplementation, :name clojure.core.matrix.protocols/new-matrix, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m rows columns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 36, :end-line 62, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m rows columns])), :doc "Returns a new matrix (regular 2D matrix) with the given number of rows and columns, filled with numeric zero."}, shift {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 708, :column 4, :end-line 708, :end-column 9, :protocol clojure.core.matrix.protocols/PShift, :doc "Shift along a single specified dimension", :arglists (quote ([m dim places]))}, :protocol clojure.core.matrix.protocols/PShift, :name clojure.core.matrix.protocols/shift, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m dim places]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 705, :end-line 708, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m dim places])), :doc "Shift along a single specified dimension"}, to-radians! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 925, :column 4, :end-line 925, :end-column 15, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/to-radians!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 925, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, element-seq {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 987, :column 4, :end-line 987, :end-column 15, :protocol clojure.core.matrix.protocols/PFunctionalOperations, :doc "Must return a seqable object containing all elements of the matrix, in row-major order.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PFunctionalOperations, :name clojure.core.matrix.protocols/element-seq, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 983, :end-line 987, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Must return a seqable object containing all elements of the matrix, in row-major order."}, softplus {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 834, :column 4, :end-line 834, :end-column 12, :protocol clojure.core.matrix.protocols/PSoftplus, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PSoftplus, :name clojure.core.matrix.protocols/softplus, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 12, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 832, :end-line 834, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, ceil {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 886, :column 4, :end-line 886, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/ceil, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 886, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, set-0d! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 236, :column 4, :end-line 236, :end-column 11, :protocol clojure.core.matrix.protocols/PZeroDimensionAccess, :doc "Sets the scalar value in the 0d array to a given value. Throws an error if not mutable.", :arglists (quote ([m value]))}, :protocol clojure.core.matrix.protocols/PZeroDimensionAccess, :name clojure.core.matrix.protocols/set-0d!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 227, :end-line 236, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m value])), :doc "Sets the scalar value in the 0d array to a given value. Throws an error if not mutable."}, to-vector {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 779, :column 4, :end-line 779, :end-column 13, :protocol clojure.core.matrix.protocols/PVectorisable, :doc "Returns an array as a single flattened vector", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PVectorisable, :name clojure.core.matrix.protocols/to-vector, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 775, :end-line 779, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns an array as a single flattened vector"}, PFunctionalOperations {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 983, :column 14, :end-line 983, :end-column 35, :doc "Protocol to allow functional-style operations on matrix elements.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {element-seq [[m]], element-map [[m f] [m f a] [m f a more]], element-map! [[m f] [m f a] [m f a more]], element-reduce [[m f] [m f init]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PFunctionalOperations, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 35, :column 1, :line 983, :protocol-info {:methods {element-seq [[m]], element-map [[m f] [m f a] [m f a more]], element-map! [[m f] [m f a] [m f a more]], element-reduce [[m f] [m f init]]}}, :info nil, :end-line 983, :impls #{}, :doc "Protocol to allow functional-style operations on matrix elements.", :jsdoc ("@interface")}, PColumnSetting {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 874, :column 14, :end-line 874, :end-column 28, :doc "Protocol for column setting. Should set a dimension 1 (column) slice to the given column value.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {set-column [[m i column]], set-column! [[m i column]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PColumnSetting, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 874, :protocol-info {:methods {set-column [[m i column]], set-column! [[m i column]]}}, :info nil, :end-line 874, :impls #{}, :doc "Protocol for column setting. Should set a dimension 1 (column) slice to the given column value.", :jsdoc ("@interface")}, get-slice-view {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 372, :column 4, :end-line 372, :end-column 18, :protocol clojure.core.matrix.protocols/PSliceView2, :doc "Gets a view of an array slice along the specified dimension.", :arglists (quote ([m dim i]))}, :protocol clojure.core.matrix.protocols/PSliceView2, :name clojure.core.matrix.protocols/get-slice-view, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([m dim i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 365, :end-line 372, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m dim i])), :doc "Gets a view of an array slice along the specified dimension."}, pre-scale {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 606, :column 4, :end-line 606, :end-column 13, :protocol clojure.core.matrix.protocols/PMatrixScaling, :doc "Pre-multiplies the array with the scalar constant. This is the same as scale for arrays\n     where multiplication is commutative, but may be different for special kinds of scalars.", :arglists (quote ([m constant]))}, :protocol clojure.core.matrix.protocols/PMatrixScaling, :name clojure.core.matrix.protocols/pre-scale, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m constant]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 598, :end-line 606, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m constant])), :doc "Pre-multiplies the array with the scalar constant. This is the same as scale for arrays\n     where multiplication is commutative, but may be different for special kinds of scalars."}, PComputeMatrix {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 679, :column 14, :end-line 679, :end-column 28, :doc "Protocol to compute a matrix by calling a function on each indexed location. The function f will be called\n   as (f x y z ...) for all index values.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {compute-matrix [[m shape f]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PComputeMatrix, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 679, :protocol-info {:methods {compute-matrix [[m shape f]]}}, :info nil, :end-line 679, :impls #{}, :doc "Protocol to compute a matrix by calling a function on each indexed location. The function f will be called\n   as (f x y z ...) for all index values.", :jsdoc ("@interface")}, abs! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 905, :column 4, :end-line 905, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/abs!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 905, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, labels {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1122, :column 4, :end-line 1122, :end-column 10, :protocol clojure.core.matrix.protocols/PDimensionLabels, :doc "Returns all labels along a given dimension, as a vector", :arglists (quote ([m dim]))}, :protocol clojure.core.matrix.protocols/PDimensionLabels, :name clojure.core.matrix.protocols/labels, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m dim]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1119, :end-line 1122, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m dim])), :doc "Returns all labels along a given dimension, as a vector"}, zero-count {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 437, :column 4, :end-line 437, :end-column 14, :protocol clojure.core.matrix.protocols/PZeroCount, :doc "Returns the number of zeros in the array", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PZeroCount, :name clojure.core.matrix.protocols/zero-count, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 434, :end-line 437, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the number of zeros in the array"}, swap-rows {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 862, :column 4, :end-line 862, :end-column 13, :protocol clojure.core.matrix.protocols/PRowOperations, :doc "Returns a new matrix with rows i and j swapped", :arglists (quote ([m i j]))}, :protocol clojure.core.matrix.protocols/PRowOperations, :name clojure.core.matrix.protocols/swap-rows, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m i j]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 860, :end-line 862, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m i j])), :doc "Returns a new matrix with rows i and j swapped"}, select-rows {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1174, :column 4, :end-line 1174, :end-column 15, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :doc "Produces a new dataset with specified rows", :arglists (quote ([ds rows]))}, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :name clojure.core.matrix.protocols/select-rows, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([ds rows]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1170, :end-line 1174, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ds rows])), :doc "Produces a new dataset with specified rows"}, PNegation {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 799, :column 14, :end-line 799, :end-column 23, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {negate [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PNegation, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :column 1, :line 799, :protocol-info {:methods {negate [[m]]}}, :info nil, :end-line 799, :impls #{}, :doc nil, :jsdoc ("@interface")}, PSparse {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 194, :column 14, :end-line 194, :end-column 21, :doc "Protocol for constructing a sparse array from the given data. Implementations should\n   consider the possibility that data may be a large lazy sequence, possibly larger than memory, so should ideally\n   attempt to construct the sparse matrix incrementally without realising the whole sequence at once.\n\n   May return nil if no sparse conversion is available.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {sparse-coerce [[m data]], sparse [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSparse, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 21, :column 1, :line 194, :protocol-info {:methods {sparse-coerce [[m data]], sparse [[m]]}}, :info nil, :end-line 194, :impls #{}, :doc "Protocol for constructing a sparse array from the given data. Implementations should\n   consider the possibility that data may be a large lazy sequence, possibly larger than memory, so should ideally\n   attempt to construct the sparse matrix incrementally without realising the whole sequence at once.\n\n   May return nil if no sparse conversion is available.", :jsdoc ("@interface")}, PSubMatrix {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 672, :column 14, :end-line 672, :end-column 24, :doc "Protocol to get a subarray of another array. dim-ranges should be a sequence of [start len]\n   pairs, one for each dimension. If a pair is nil, it should be interpreted to take the whole dimension.\n\n   Returning a mutable view is preferred, if the implementation supports this.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {submatrix [[d dim-ranges]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSubMatrix, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 672, :protocol-info {:methods {submatrix [[d dim-ranges]]}}, :info nil, :end-line 672, :impls #{}, :doc "Protocol to get a subarray of another array. dim-ranges should be a sequence of [start len]\n   pairs, one for each dimension. If a pair is nil, it should be interpreted to take the whole dimension.\n\n   Returning a mutable view is preferred, if the implementation supports this.", :jsdoc ("@interface")}, block-diagonal-matrix {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 259, :column 4, :end-line 259, :end-column 25, :protocol clojure.core.matrix.protocols/PBlockDiagonalMatrix, :doc nil, :arglists (quote ([m blocks]))}, :protocol clojure.core.matrix.protocols/PBlockDiagonalMatrix, :name clojure.core.matrix.protocols/block-diagonal-matrix, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :method-params ([m blocks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 257, :end-line 259, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m blocks])), :doc nil}, element-max {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 936, :column 4, :end-line 936, :end-column 15, :protocol clojure.core.matrix.protocols/PElementMinMax, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PElementMinMax, :name clojure.core.matrix.protocols/element-max, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 932, :end-line 936, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, multiply-row {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 864, :column 4, :end-line 864, :end-column 16, :protocol clojure.core.matrix.protocols/PRowOperations, :doc "Returns a new matrix with row i multiplied by k", :arglists (quote ([m i k]))}, :protocol clojure.core.matrix.protocols/PRowOperations, :name clojure.core.matrix.protocols/multiply-row, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :method-params ([m i k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 860, :end-line 864, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m i k])), :doc "Returns a new matrix with row i multiplied by k"}, PMatrixPredicates {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1032, :column 14, :end-line 1032, :end-column 31, :doc "Protocol for matrix predicates like identity-matrix? or zero-matrix?", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {identity-matrix? [[m]], zero-matrix? [[m]], symmetric? [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixPredicates, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 31, :column 1, :line 1032, :protocol-info {:methods {identity-matrix? [[m]], zero-matrix? [[m]], symmetric? [[m]]}}, :info nil, :end-line 1032, :impls #{}, :doc "Protocol for matrix predicates like identity-matrix? or zero-matrix?", :jsdoc ("@interface")}, log! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 915, :column 4, :end-line 915, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/log!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 915, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, vector-transform {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 595, :column 4, :end-line 595, :end-column 20, :protocol clojure.core.matrix.protocols/PVectorTransform, :doc "Transforms a vector", :arglists (quote ([t v]))}, :protocol clojure.core.matrix.protocols/PVectorTransform, :name clojure.core.matrix.protocols/vector-transform, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :method-params ([t v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 589, :end-line 595, :max-fixed-arity 2, :fn-var true, :arglists (quote ([t v])), :doc "Transforms a vector"}, PVectorTransform {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 589, :column 14, :end-line 589, :end-column 30, :doc "Protocol to support transformation of a vector to another vector. Is equivalent to matrix multiplication\n   when 2D matrices are used as transformations. But other transformations are possible, e.g. non-affine\n   transformations.\n\n   A transformation need not be a core.matrix matrix: other types are permissible", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {vector-transform [[t v]], vector-transform! [[t v]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PVectorTransform, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 30, :column 1, :line 589, :protocol-info {:methods {vector-transform [[t v]], vector-transform! [[t v]]}}, :info nil, :end-line 589, :impls #{}, :doc "Protocol to support transformation of a vector to another vector. Is equivalent to matrix multiplication\n   when 2D matrices are used as transformations. But other transformations are possible, e.g. non-affine\n   transformations.\n\n   A transformation need not be a core.matrix matrix: other types are permissible", :jsdoc ("@interface")}, replace-column {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1180, :column 4, :end-line 1180, :end-column 18, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :doc "Replaces column in a dataset with new values", :arglists (quote ([ds col-name vs]))}, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :name clojure.core.matrix.protocols/replace-column, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([ds col-name vs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1170, :end-line 1180, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ds col-name vs])), :doc "Replaces column in a dataset with new values"}, new-vector {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 60, :column 4, :end-line 60, :end-column 14, :protocol clojure.core.matrix.protocols/PImplementation, :doc "Returns a new vector (1D column matrix) of the given length, filled with numeric zero.", :arglists (quote ([m length]))}, :protocol clojure.core.matrix.protocols/PImplementation, :name clojure.core.matrix.protocols/new-vector, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m length]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 36, :end-line 60, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m length])), :doc "Returns a new vector (1D column matrix) of the given length, filled with numeric zero."}, persistent-vector-coerce {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1187, :column 7, :end-line 1187, :end-column 31, :arglists (quote ([x])), :doc "Coerces a data structure to nested persistent vectors"}, :name clojure.core.matrix.protocols/persistent-vector-coerce, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1187, :end-line 1187, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerces a data structure to nested persistent vectors"}, element-sum {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 811, :column 4, :end-line 811, :end-column 15, :protocol clojure.core.matrix.protocols/PSummable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PSummable, :name clojure.core.matrix.protocols/element-sum, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 808, :end-line 811, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, add-column {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1175, :column 4, :end-line 1175, :end-column 14, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :doc "Adds column to the dataset", :arglists (quote ([ds col-name col]))}, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :name clojure.core.matrix.protocols/add-column, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([ds col-name col]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1170, :end-line 1175, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ds col-name col])), :doc "Adds column to the dataset"}, PDatasetImplementation {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1170, :column 14, :end-line 1170, :end-column 36, :doc "Protocol for general dataset functionality", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {select-columns [[ds cols]], rename-columns [[ds col-map]], to-map [[ds]], select-rows [[ds rows]], replace-column [[ds col-name vs]], add-column [[ds col-name col]], join-rows [[ds1 ds2]], columns [[ds]], row-maps [[ds]], join-columns [[ds1 ds2]], merge-datasets [[ds1 ds2]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PDatasetImplementation, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 36, :column 1, :line 1170, :protocol-info {:methods {select-columns [[ds cols]], rename-columns [[ds col-map]], to-map [[ds]], select-rows [[ds rows]], replace-column [[ds col-name vs]], add-column [[ds col-name col]], join-rows [[ds1 ds2]], columns [[ds]], row-maps [[ds]], join-columns [[ds1 ds2]], merge-datasets [[ds1 ds2]]}}, :info nil, :end-line 1170, :impls #{}, :doc "Protocol for general dataset functionality", :jsdoc ("@interface")}, transpose! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 717, :column 4, :end-line 717, :end-column 14, :protocol clojure.core.matrix.protocols/PTransposeInPlace, :doc "Transposes a mutable 2D matrix in place", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PTransposeInPlace, :name clojure.core.matrix.protocols/transpose!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 715, :end-line 717, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Transposes a mutable 2D matrix in place"}, atan {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 884, :column 4, :end-line 884, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/atan, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 884, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PRowOperations {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 860, :column 14, :end-line 860, :end-column 28, :doc "Protocol for elementary row operations", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {swap-rows [[m i j]], multiply-row [[m i k]], add-row [[m i j k]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PRowOperations, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 860, :protocol-info {:methods {swap-rows [[m i j]], multiply-row [[m i k]], add-row [[m i j k]]}}, :info nil, :end-line 860, :impls #{}, :doc "Protocol for elementary row operations", :jsdoc ("@interface")}, cosh! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 912, :column 4, :end-line 912, :end-column 9, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/cosh!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 912, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PZeroDimensionAccess {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 227, :column 14, :end-line 227, :end-column 34, :doc "Protocol for accessing the scalar value in zero-dimensional arrays. Zero dimensional arrays differ\n   from scalar values in the following two senses:\n    - They may be mutable (in which case set-0d! is expected to work)\n    - They are not considered themselves to be scalars. Hence you must use get-0d to access the\n      contained scalar value", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {get-0d [[m]], set-0d! [[m value]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PZeroDimensionAccess, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 34, :column 1, :line 227, :protocol-info {:methods {get-0d [[m]], set-0d! [[m value]]}}, :info nil, :end-line 227, :impls #{}, :doc "Protocol for accessing the scalar value in zero-dimensional arrays. Zero dimensional arrays differ\n   from scalar values in the following two senses:\n    - They may be mutable (in which case set-0d! is expected to work)\n    - They are not considered themselves to be scalars. Hence you must use get-0d to access the\n      contained scalar value", :jsdoc ("@interface")}, PEigenDecomposition {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1154, :column 14, :end-line 1154, :end-column 33, :doc "Procotol for Eigenvalue decomposition", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {eigen [[m options]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PEigenDecomposition, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 33, :column 1, :line 1154, :protocol-info {:methods {eigen [[m options]]}}, :info nil, :end-line 1154, :impls #{}, :doc "Procotol for Eigenvalue decomposition", :jsdoc ("@interface")}, index-coerce {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1114, :column 4, :end-line 1114, :end-column 16, :protocol clojure.core.matrix.protocols/PIndexImplementation, :doc nil, :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PIndexImplementation, :name clojure.core.matrix.protocols/index-coerce, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1107, :end-line 1114, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc nil}, new-matrix-nd {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 64, :column 4, :end-line 64, :end-column 17, :protocol clojure.core.matrix.protocols/PImplementation, :doc "Returns a new general matrix of the given shape.\n     Must return nil if the shape is not supported by the implementation.\n     Shape can be any sequence of integer dimension sizes (including 0 dimensions).", :arglists (quote ([m shape]))}, :protocol clojure.core.matrix.protocols/PImplementation, :name clojure.core.matrix.protocols/new-matrix-nd, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([m shape]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 36, :end-line 64, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m shape])), :doc "Returns a new general matrix of the given shape.\n     Must return nil if the shape is not supported by the implementation.\n     Shape can be any sequence of integer dimension sizes (including 0 dimensions)."}, PMathsFunctions {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 879, :column 14, :end-line 879, :end-column 29, :doc "Protocol to support mathematical functions applied element-wise to a numerical array.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {to-radians [[m]], log [[m]], acos [[m]], to-degrees [[m]], floor [[m]], tanh [[m]], ceil [[m]], atan [[m]], cos [[m]], log10 [[m]], tan [[m]], cbrt [[m]], sqrt [[m]], exp [[m]], cosh [[m]], asin [[m]], round [[m]], abs [[m]], sinh [[m]], sin [[m]], signum [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMathsFunctions, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :column 1, :line 879, :protocol-info {:methods {to-radians [[m]], log [[m]], acos [[m]], to-degrees [[m]], floor [[m]], tanh [[m]], ceil [[m]], atan [[m]], cos [[m]], log10 [[m]], tan [[m]], cbrt [[m]], sqrt [[m]], exp [[m]], cosh [[m]], asin [[m]], round [[m]], abs [[m]], sinh [[m]], sin [[m]], signum [[m]]}}, :info nil, :end-line 879, :impls #{}, :doc "Protocol to support mathematical functions applied element-wise to a numerical array.", :jsdoc ("@interface")}, PCoercion {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 261, :column 14, :end-line 261, :end-column 23, :doc "Protocol to coerce a parameter to a format used by a specific implementation. It is\n   up to the implementation to determine what parameter types they support.\n   If the implementation is unable to perform coercion, it must return nil.\n\n   Implementations are encouraged to avoid taking a full copy of the data, for performance reasons.\n   It is preferable to use structural sharing with the original data if possible.\n\n   If coercion is impossible (e.g. param has an invalid shape or element types) then the\n   implementation *may* throw an exception, though it may also return nil to get default behaviour,\n   which should implement any expected exceptions.\n\n   If an implementation implements coercion via copying, then it is recommended that conversion\n   should be to the most efficient packed representation (i.e. as defined by 'pack')\n\n   Implementations must also be able to coerce valid scalar values (presumably via the identity function)", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {coerce-param [[m param]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PCoercion, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :column 1, :line 261, :protocol-info {:methods {coerce-param [[m param]]}}, :info nil, :end-line 261, :impls #{}, :doc "Protocol to coerce a parameter to a format used by a specific implementation. It is\n   up to the implementation to determine what parameter types they support.\n   If the implementation is unable to perform coercion, it must return nil.\n\n   Implementations are encouraged to avoid taking a full copy of the data, for performance reasons.\n   It is preferable to use structural sharing with the original data if possible.\n\n   If coercion is impossible (e.g. param has an invalid shape or element types) then the\n   implementation *may* throw an exception, though it may also return nil to get default behaviour,\n   which should implement any expected exceptions.\n\n   If an implementation implements coercion via copying, then it is recommended that conversion\n   should be to the most efficient packed representation (i.e. as defined by 'pack')\n\n   Implementations must also be able to coerce valid scalar values (presumably via the identity function)", :jsdoc ("@interface")}, PRowSetting {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 869, :column 14, :end-line 869, :end-column 25, :doc "Protocol for row setting. Should set a dimension 0 (row) slice to thegiven row value.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {set-row [[m i row]], set-row! [[m i row]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PRowSetting, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :column 1, :line 869, :protocol-info {:methods {set-row [[m i row]], set-row! [[m i row]]}}, :info nil, :end-line 869, :impls #{}, :doc "Protocol for row setting. Should set a dimension 0 (row) slice to thegiven row value.", :jsdoc ("@interface")}, get-major-slice-view-seq {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 397, :column 4, :end-line 397, :end-column 28, :protocol clojure.core.matrix.protocols/PSliceViewSeq, :doc "Gets a sequence of all major array slices", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PSliceViewSeq, :name clojure.core.matrix.protocols/get-major-slice-view-seq, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 392, :end-line 397, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Gets a sequence of all major array slices"}, ensure-mutable {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 190, :column 4, :end-line 190, :end-column 18, :protocol clojure.core.matrix.protocols/PMutableCoercion, :doc "Returns this array if fully mutable, otherwise returns a new mutable array containing\n                   a copy of this array. May return nil if the implementation cannot create a suitable mutable\n                   array.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMutableCoercion, :name clojure.core.matrix.protocols/ensure-mutable, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 183, :end-line 190, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns this array if fully mutable, otherwise returns a new mutable array containing\n                   a copy of this array. May return nil if the implementation cannot create a suitable mutable\n                   array."}, diagonal-matrix {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 249, :column 4, :end-line 249, :end-column 19, :protocol clojure.core.matrix.protocols/PSpecialisedConstructors, :doc "Create a diagonal matrix with the specified leading diagonal values", :arglists (quote ([m diagonal-values]))}, :protocol clojure.core.matrix.protocols/PSpecialisedConstructors, :name clojure.core.matrix.protocols/diagonal-matrix, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([m diagonal-values]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 244, :end-line 249, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m diagonal-values])), :doc "Create a diagonal matrix with the specified leading diagonal values"}, set-inner-product! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 667, :column 4, :end-line 667, :end-column 22, :protocol clojure.core.matrix.protocols/PSetInnerProductMutable, :doc "Sets m to the inner product of a, b and an optional scalar factor to m", :arglists (quote ([m a b] [m a b factor])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m a b] [m a b factor]), :arglists ([m a b] [m a b factor]), :arglists-meta (nil nil)}}, :protocol clojure.core.matrix.protocols/PSetInnerProductMutable, :name clojure.core.matrix.protocols/set-inner-product!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 22, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m a b] [m a b factor]), :arglists ([m a b] [m a b factor]), :arglists-meta (nil nil)}, :method-params ([m a b] [m a b factor]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 663, :end-line 667, :max-fixed-arity 4, :fn-var true, :arglists ([m a b] [m a b factor]), :doc "Sets m to the inner product of a, b and an optional scalar factor to m"}, PSoftmax {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 848, :column 14, :end-line 848, :end-column 22, :doc "Protocol to support element-wise softmax function on a numerical vector.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {softmax [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSoftmax, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 22, :column 1, :line 848, :protocol-info {:methods {softmax [[m]]}}, :info nil, :end-line 848, :impls #{}, :doc "Protocol to support element-wise softmax function on a numerical vector.", :jsdoc ("@interface")}, sin! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 919, :column 4, :end-line 919, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/sin!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 919, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, normalise! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 785, :column 4, :end-line 785, :end-column 14, :protocol clojure.core.matrix.protocols/PMutableVectorOps, :doc nil, :arglists (quote ([a]))}, :protocol clojure.core.matrix.protocols/PMutableVectorOps, :name clojure.core.matrix.protocols/normalise!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 783, :end-line 785, :max-fixed-arity 1, :fn-var true, :arglists (quote ([a])), :doc nil}, element-count {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 930, :column 4, :end-line 930, :end-column 17, :protocol clojure.core.matrix.protocols/PElementCount, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PElementCount, :name clojure.core.matrix.protocols/element-count, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 927, :end-line 930, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PAddInnerProductMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 645, :column 14, :end-line 645, :end-column 37, :doc "Protocol to support the mutable add-inner-product! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant factors e.g. 0.0 and 1.0 but this is not mandatory.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {add-inner-product! [[m a b] [m a b factor]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PAddInnerProductMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 37, :column 1, :line 645, :protocol-info {:methods {add-inner-product! [[m a b] [m a b factor]]}}, :info nil, :end-line 645, :impls #{}, :doc "Protocol to support the mutable add-inner-product! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant factors e.g. 0.0 and 1.0 but this is not mandatory.", :jsdoc ("@interface")}, PMatrixAdd {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 615, :column 14, :end-line 615, :end-column 24, :doc "Protocol to support addition and subtraction on arbitrary matrices.\n   These are elementwise operations that should support broadcasting.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {matrix-add [[m a]], matrix-sub [[m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixAdd, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 615, :protocol-info {:methods {matrix-add [[m a]], matrix-sub [[m a]]}}, :info nil, :end-line 615, :impls #{}, :doc "Protocol to support addition and subtraction on arbitrary matrices.\n   These are elementwise operations that should support broadcasting.", :jsdoc ("@interface")}, supports-dimensionality? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 68, :column 4, :end-line 68, :end-column 28, :protocol clojure.core.matrix.protocols/PImplementation, :doc "Returns true if the implementation supports matrices with the given number of dimensions.", :arglists (quote ([m dimensions]))}, :protocol clojure.core.matrix.protocols/PImplementation, :name clojure.core.matrix.protocols/supports-dimensionality?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :method-params ([m dimensions]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 36, :end-line 68, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m dimensions])), :doc "Returns true if the implementation supports matrices with the given number of dimensions."}, softmax {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 850, :column 4, :end-line 850, :end-column 11, :protocol clojure.core.matrix.protocols/PSoftmax, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PSoftmax, :name clojure.core.matrix.protocols/softmax, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 848, :end-line 850, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PSubVector {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 407, :column 14, :end-line 407, :end-column 24, :doc "Protocol for getting a sub-vector view of a vector. Must return a mutable view\n   if the original vector is mutable. Should throw an exception if the specified\n   subvector is out of bounds for the target vector.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {subvector [[m start length]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSubVector, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 407, :protocol-info {:methods {subvector [[m start length]]}}, :info nil, :end-line 407, :impls #{}, :doc "Protocol for getting a sub-vector view of a vector. Must return a mutable view\n   if the original vector is mutable. Should throw an exception if the specified\n   subvector is out of bounds for the target vector.", :jsdoc ("@interface")}, lu {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1148, :column 4, :end-line 1148, :end-column 6, :protocol clojure.core.matrix.protocols/PLUDecomposition, :doc nil, :arglists (quote ([m options]))}, :protocol clojure.core.matrix.protocols/PLUDecomposition, :name clojure.core.matrix.protocols/lu, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 6, :method-params ([m options]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1146, :end-line 1148, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m options])), :doc nil}, set-selection {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1090, :column 4, :end-line 1090, :end-column 17, :protocol clojure.core.matrix.protocols/PSetSelection, :doc "sets the elements in the selection of a to values", :arglists (quote ([a args values]))}, :protocol clojure.core.matrix.protocols/PSetSelection, :name clojure.core.matrix.protocols/set-selection, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([a args values]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1087, :end-line 1090, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a args values])), :doc "sets the elements in the selection of a to values"}, logistic {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 826, :column 4, :end-line 826, :end-column 12, :protocol clojure.core.matrix.protocols/PLogistic, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PLogistic, :name clojure.core.matrix.protocols/logistic, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 12, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 824, :end-line 826, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, cos {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 887, :column 4, :end-line 887, :end-column 7, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/cos, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 7, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 887, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PScaleAdd {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 626, :column 14, :end-line 626, :end-column 23, :doc "Protocol to support the mutable scale-add! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant values e.g. 0.0 and 1.0 but this is not mandatory.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {scale-add! [[m1 a m2 b constant]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PScaleAdd, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :column 1, :line 626, :protocol-info {:methods {scale-add! [[m1 a m2 b constant]]}}, :info nil, :end-line 626, :impls #{}, :doc "Protocol to support the mutable scale-add! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant values e.g. 0.0 and 1.0 but this is not mandatory.", :jsdoc ("@interface")}, non-zero-indices {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1103, :column 5, :end-line 1103, :end-column 21, :protocol clojure.core.matrix.protocols/PNonZeroIndices, :doc "Gets the non-zero indices of an array.\n                         - For a 1D vector, returns an ordered index list.\n                         - For a higher dimensional array, returns the non-zero-indices for each slice in row-major order.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PNonZeroIndices, :name clojure.core.matrix.protocols/non-zero-indices, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 21, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1101, :end-line 1103, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Gets the non-zero indices of an array.\n                         - For a 1D vector, returns an ordered index list.\n                         - For a higher dimensional array, returns the non-zero-indices for each slice in row-major order."}, cholesky {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1144, :column 4, :end-line 1144, :end-column 12, :protocol clojure.core.matrix.protocols/PCholeskyDecomposition, :doc nil, :arglists (quote ([m options]))}, :protocol clojure.core.matrix.protocols/PCholeskyDecomposition, :name clojure.core.matrix.protocols/cholesky, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 12, :method-params ([m options]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1142, :end-line 1144, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m options])), :doc nil}, least-squares {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1164, :column 4, :end-line 1164, :end-column 17, :protocol clojure.core.matrix.protocols/PLeastSquares, :doc nil, :arglists (quote ([a b]))}, :protocol clojure.core.matrix.protocols/PLeastSquares, :name clojure.core.matrix.protocols/least-squares, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1162, :end-line 1164, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :doc nil}, log10 {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 892, :column 4, :end-line 892, :end-column 9, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/log10, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 892, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, qr {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1140, :column 4, :end-line 1140, :end-column 6, :protocol clojure.core.matrix.protocols/PQRDecomposition, :doc nil, :arglists (quote ([m options]))}, :protocol clojure.core.matrix.protocols/PQRDecomposition, :name clojure.core.matrix.protocols/qr, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 6, :method-params ([m options]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1138, :end-line 1140, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m options])), :doc nil}, matrix-add! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 623, :column 4, :end-line 623, :end-column 15, :protocol clojure.core.matrix.protocols/PMatrixAddMutable, :doc nil, :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PMatrixAddMutable, :name clojure.core.matrix.protocols/matrix-add!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 621, :end-line 623, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc nil}, tan {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 898, :column 4, :end-line 898, :end-column 7, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/tan, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 7, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 898, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, cbrt {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 885, :column 4, :end-line 885, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/cbrt, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 885, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, as-double-array {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 470, :column 4, :end-line 470, :end-column 19, :protocol clojure.core.matrix.protocols/PDoubleArrayOutput, :doc "Returns the internal double array used by m. If no such array is used, returns nil.\n     Provides an opportunity to avoid copying the internal array.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PDoubleArrayOutput, :name clojure.core.matrix.protocols/as-double-array, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 464, :end-line 470, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the internal double array used by m. If no such array is used, returns nil.\n     Provides an opportunity to avoid copying the internal array."}, PAddScaled {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 552, :column 14, :end-line 552, :end-column 24, :doc "Protocol for add-scaled operation.\n\n   Implementations may assume that factor is a scalar.\n\n   Intended to support optimised implementations for result = m + a * factor", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {add-scaled [[m a factor]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PAddScaled, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 552, :protocol-info {:methods {add-scaled [[m a factor]]}}, :info nil, :end-line 552, :impls #{}, :doc "Protocol for add-scaled operation.\n\n   Implementations may assume that factor is a scalar.\n\n   Intended to support optimised implementations for result = m + a * factor", :jsdoc ("@interface")}, PLUDecomposition {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1146, :column 14, :end-line 1146, :end-column 30, :doc "Protocol for LU decomposition", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {lu [[m options]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PLUDecomposition, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 30, :column 1, :line 1146, :protocol-info {:methods {lu [[m options]]}}, :info nil, :end-line 1146, :impls #{}, :doc "Protocol for LU decomposition", :jsdoc ("@interface")}, PValidateShape {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 160, :column 14, :end-line 160, :end-column 28, :doc "Optional protocol to validate the shape of a matrix. If the matrix has an incorrect shape, should\n   throw an error. Otherwise it should return the correct shape.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {validate-shape [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PValidateShape, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 160, :protocol-info {:methods {validate-shape [[m]]}}, :info nil, :end-line 160, :impls #{}, :doc "Optional protocol to validate the shape of a matrix. If the matrix has an incorrect shape, should\n   throw an error. Otherwise it should return the correct shape.", :jsdoc ("@interface")}, softmax! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 854, :column 4, :end-line 854, :end-column 12, :protocol clojure.core.matrix.protocols/PSoftmaxMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PSoftmaxMutable, :name clojure.core.matrix.protocols/softmax!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 12, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 852, :end-line 854, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, index-to-longs {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1110, :column 4, :end-line 1110, :end-column 18, :protocol clojure.core.matrix.protocols/PIndexImplementation, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PIndexImplementation, :name clojure.core.matrix.protocols/index-to-longs, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1107, :end-line 1110, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, generic-negate {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1069, :column 4, :end-line 1069, :end-column 18, :protocol clojure.core.matrix.protocols/PGenericOperations, :doc "Generic 'negate' function for numerical values.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PGenericOperations, :name clojure.core.matrix.protocols/generic-negate, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1065, :end-line 1069, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Generic 'negate' function for numerical values."}, element-map-indexed! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1022, :column 4, :end-line 1022, :end-column 24, :protocol clojure.core.matrix.protocols/PMapIndexed, :doc "Maps f over all elements of m (and optionally other matrices), mutating the elements of m in place.\n     Must throw an exception if m is not mutable.\n     f is expected to accept an index vector and the current element value, and produce\n     elements of a type supported by the implementation of m - failure\n     to do so may cause an error.", :arglists (quote ([m f] [m f a] [m f a more])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m f] [m f a] [m f a more]), :arglists ([m f] [m f a] [m f a more]), :arglists-meta (nil nil nil)}}, :protocol clojure.core.matrix.protocols/PMapIndexed, :name clojure.core.matrix.protocols/element-map-indexed!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m f] [m f a] [m f a more]), :arglists ([m f] [m f a] [m f a more]), :arglists-meta (nil nil nil)}, :method-params ([m f] [m f a] [m f a more]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1010, :end-line 1022, :max-fixed-arity 4, :fn-var true, :arglists ([m f] [m f a] [m f a more]), :doc "Maps f over all elements of m (and optionally other matrices), mutating the elements of m in place.\n     Must throw an exception if m is not mutable.\n     f is expected to accept an index vector and the current element value, and produce\n     elements of a type supported by the implementation of m - failure\n     to do so may cause an error."}, PAddOuterProductMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 654, :column 14, :end-line 654, :end-column 37, :doc "Protocol to support the mutable add-outer-product! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant factors e.g. 0.0 and 1.0 but this is not mandatory.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {add-outer-product! [[m a b] [m a b factor]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PAddOuterProductMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 37, :column 1, :line 654, :protocol-info {:methods {add-outer-product! [[m a b] [m a b factor]]}}, :info nil, :end-line 654, :impls #{}, :doc "Protocol to support the mutable add-outer-product! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant factors e.g. 0.0 and 1.0 but this is not mandatory.", :jsdoc ("@interface")}, submatrix {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 677, :column 4, :end-line 677, :end-column 13, :protocol clojure.core.matrix.protocols/PSubMatrix, :doc nil, :arglists (quote ([d dim-ranges]))}, :protocol clojure.core.matrix.protocols/PSubMatrix, :name clojure.core.matrix.protocols/submatrix, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([d dim-ranges]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 672, :end-line 677, :max-fixed-arity 2, :fn-var true, :arglists (quote ([d dim-ranges])), :doc nil}, tan! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 922, :column 4, :end-line 922, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/tan!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 922, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, lerp! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 642, :column 4, :end-line 642, :end-column 9, :protocol clojure.core.matrix.protocols/PLerp, :doc "Linear interpolation: Scales array a by (1-factor), then adds array b scaled by factor. Mutates a.", :arglists (quote ([a b factor]))}, :protocol clojure.core.matrix.protocols/PLerp, :name clojure.core.matrix.protocols/lerp!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([a b factor]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 638, :end-line 642, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a b factor])), :doc "Linear interpolation: Scales array a by (1-factor), then adds array b scaled by factor. Mutates a."}, join-rows {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1181, :column 4, :end-line 1181, :end-column 13, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :doc "Returns a dataset created by combining the rows of the given datasets", :arglists (quote ([ds1 ds2]))}, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :name clojure.core.matrix.protocols/join-rows, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([ds1 ds2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1170, :end-line 1181, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ds1 ds2])), :doc "Returns a dataset created by combining the rows of the given datasets"}, element-multiply! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 587, :column 4, :end-line 587, :end-column 21, :protocol clojure.core.matrix.protocols/PMatrixMultiplyMutable, :doc nil, :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PMatrixMultiplyMutable, :name clojure.core.matrix.protocols/element-multiply!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 21, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 584, :end-line 587, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc nil}, set-indices! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1099, :column 4, :end-line 1099, :end-column 16, :protocol clojure.core.matrix.protocols/PIndicesSetting, :doc "destructively sets the elements from a at indices to values", :arglists (quote ([a indices values]))}, :protocol clojure.core.matrix.protocols/PIndicesSetting, :name clojure.core.matrix.protocols/set-indices!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :method-params ([a indices values]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1096, :end-line 1099, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a indices values])), :doc "destructively sets the elements from a at indices to values"}, PSameShape {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 330, :column 14, :end-line 330, :end-column 24, :doc "Protocol to test if two arrays have the same shape. Implementations may have an optimised\n   method for shape equality tests, and this is a frequently required operations so it may\n   make sense to provide an optimised implementation.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {same-shape? [[a b]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSameShape, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 330, :protocol-info {:methods {same-shape? [[a b]]}}, :info nil, :end-line 330, :impls #{}, :doc "Protocol to test if two arrays have the same shape. Implementations may have an optimised\n   method for shape equality tests, and this is a frequently required operations so it may\n   make sense to provide an optimised implementation.", :jsdoc ("@interface")}, add-row {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 866, :column 4, :end-line 866, :end-column 11, :protocol clojure.core.matrix.protocols/PRowOperations, :doc "Returns a new matrix with row i added to row j times k", :arglists (quote ([m i j k]))}, :protocol clojure.core.matrix.protocols/PRowOperations, :name clojure.core.matrix.protocols/add-row, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m i j k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 860, :end-line 866, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m i j k])), :doc "Returns a new matrix with row i added to row j times k"}, column-matrix {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 173, :column 4, :end-line 173, :end-column 17, :protocol clojure.core.matrix.protocols/PRowColMatrix, :doc nil, :arglists (quote ([m data]))}, :protocol clojure.core.matrix.protocols/PRowColMatrix, :name clojure.core.matrix.protocols/column-matrix, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([m data]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 167, :end-line 173, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m data])), :doc nil}, PBlockDiagonalMatrix {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 257, :column 14, :end-line 257, :end-column 34, :doc "Protocol for construction of a block diagonal matrix.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {block-diagonal-matrix [[m blocks]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PBlockDiagonalMatrix, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 34, :column 1, :line 257, :protocol-info {:methods {block-diagonal-matrix [[m blocks]]}}, :info nil, :end-line 257, :impls #{}, :doc "Protocol for construction of a block diagonal matrix.", :jsdoc ("@interface")}, PMatrixRows {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 348, :column 14, :end-line 348, :end-column 25, :doc "Protocol for accessing rows of a matrix", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {get-rows [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixRows, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :column 1, :line 348, :protocol-info {:methods {get-rows [[m]]}}, :info nil, :end-line 348, :impls #{}, :doc "Protocol for accessing rows of a matrix", :jsdoc ("@interface")}, value-equals {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 489, :column 4, :end-line 489, :end-column 16, :protocol clojure.core.matrix.protocols/PValueEquality, :doc "Returns true if two arrays are equal both in shape and according to clojure.core/= for each element.", :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PValueEquality, :name clojure.core.matrix.protocols/value-equals, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 486, :end-line 489, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc "Returns true if two arrays are equal both in shape and according to clojure.core/= for each element."}, exp! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 913, :column 4, :end-line 913, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/exp!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 913, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, add-scaled {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 558, :column 4, :end-line 558, :end-column 14, :protocol clojure.core.matrix.protocols/PAddScaled, :doc nil, :arglists (quote ([m a factor]))}, :protocol clojure.core.matrix.protocols/PAddScaled, :name clojure.core.matrix.protocols/add-scaled, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m a factor]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 552, :end-line 558, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m a factor])), :doc nil}, matrix-sub! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 624, :column 4, :end-line 624, :end-column 15, :protocol clojure.core.matrix.protocols/PMatrixAddMutable, :doc nil, :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PMatrixAddMutable, :name clojure.core.matrix.protocols/matrix-sub!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 621, :end-line 624, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc nil}, PCompare {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 941, :column 14, :end-line 941, :end-column 22, :doc "Protocol to allow element-wise comparison of elements in an array or matrix.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {element-compare [[a b]], element-if [[m a b]], element-lt [[m a]], element-le [[m a]], element-gt [[m a]], element-ge [[m a]], element-ne [[m a]], element-eq [[m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PCompare, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 22, :column 1, :line 941, :protocol-info {:methods {element-compare [[a b]], element-if [[m a b]], element-lt [[m a]], element-le [[m a]], element-gt [[m a]], element-ge [[m a]], element-ne [[m a]], element-eq [[m a]]}}, :info nil, :end-line 941, :impls #{}, :doc "Protocol to allow element-wise comparison of elements in an array or matrix.", :jsdoc ("@interface")}, PLogistic {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 824, :column 14, :end-line 824, :end-column 23, :doc "Protocol to support element-wise logistic function on a numerical array.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {logistic [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PLogistic, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :column 1, :line 824, :protocol-info {:methods {logistic [[m]]}}, :info nil, :end-line 824, :impls #{}, :doc "Protocol to support element-wise logistic function on a numerical array.", :jsdoc ("@interface")}, sqrt {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 897, :column 4, :end-line 897, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/sqrt, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 897, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, get-2d {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 95, :column 4, :end-line 95, :end-column 10, :protocol clojure.core.matrix.protocols/PIndexedAccess, :doc nil, :arglists (quote ([m row column]))}, :protocol clojure.core.matrix.protocols/PIndexedAccess, :name clojure.core.matrix.protocols/get-2d, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m row column]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 91, :end-line 95, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m row column])), :doc nil}, scale! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 612, :column 4, :end-line 612, :end-column 10, :protocol clojure.core.matrix.protocols/PMatrixMutableScaling, :doc nil, :arglists (quote ([m factor]))}, :protocol clojure.core.matrix.protocols/PMatrixMutableScaling, :name clojure.core.matrix.protocols/scale!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m factor]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 610, :end-line 612, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m factor])), :doc nil}, convert-to-nested-vectors {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 309, :column 4, :end-line 309, :end-column 29, :protocol clojure.core.matrix.protocols/PConversion, :doc "Converts an array to nested Clojure persistent vectors", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PConversion, :name clojure.core.matrix.protocols/convert-to-nested-vectors, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 305, :end-line 309, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Converts an array to nested Clojure persistent vectors"}, scale {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 604, :column 4, :end-line 604, :end-column 9, :protocol clojure.core.matrix.protocols/PMatrixScaling, :doc "Multiplies a array by the scalar constant, ", :arglists (quote ([m constant]))}, :protocol clojure.core.matrix.protocols/PMatrixScaling, :name clojure.core.matrix.protocols/scale, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m constant]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 598, :end-line 604, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m constant])), :doc "Multiplies a array by the scalar constant, "}, set-column! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 877, :column 4, :end-line 877, :end-column 15, :protocol clojure.core.matrix.protocols/PColumnSetting, :doc nil, :arglists (quote ([m i column]))}, :protocol clojure.core.matrix.protocols/PColumnSetting, :name clojure.core.matrix.protocols/set-column!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m i column]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 874, :end-line 877, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m i column])), :doc nil}, softplus! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 838, :column 4, :end-line 838, :end-column 13, :protocol clojure.core.matrix.protocols/PSoftplusMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PSoftplusMutable, :name clojure.core.matrix.protocols/softplus!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 836, :end-line 838, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, subvector {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 411, :column 4, :end-line 411, :end-column 13, :protocol clojure.core.matrix.protocols/PSubVector, :doc "Gets a sub-vector of a vector. Must return a view if the vector is mutable.", :arglists (quote ([m start length]))}, :protocol clojure.core.matrix.protocols/PSubVector, :name clojure.core.matrix.protocols/subvector, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m start length]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 407, :end-line 411, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m start length])), :doc "Gets a sub-vector of a vector. Must return a view if the vector is mutable."}, inner-product {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 523, :column 4, :end-line 523, :end-column 17, :protocol clojure.core.matrix.protocols/PMatrixProducts, :doc "Returns the inner product of two numerical arrays.", :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PMatrixProducts, :name clojure.core.matrix.protocols/inner-product, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 520, :end-line 523, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc "Returns the inner product of two numerical arrays."}, to-degrees! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 924, :column 4, :end-line 924, :end-column 15, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/to-degrees!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 924, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, is-scalar? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 80, :column 4, :end-line 80, :end-column 14, :protocol clojure.core.matrix.protocols/PDimensionInfo, :doc "Tests whether an object is a scalar value, i.e. a value that can exist at a\n     specific position in an array.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PDimensionInfo, :name clojure.core.matrix.protocols/is-scalar?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 71, :end-line 80, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Tests whether an object is a scalar value, i.e. a value that can exist at a\n     specific position in an array."}, cbrt! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 909, :column 4, :end-line 909, :end-column 9, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/cbrt!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 909, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, inverse {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 796, :column 4, :end-line 796, :end-column 11, :protocol clojure.core.matrix.protocols/PMatrixOps, :doc "Returns the invese of a matrix. Should return nil if m is not invertible.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixOps, :name clojure.core.matrix.protocols/inverse, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 787, :end-line 796, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the invese of a matrix. Should return nil if m is not invertible."}, element-pow {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 818, :column 4, :end-line 818, :end-column 15, :protocol clojure.core.matrix.protocols/PExponent, :doc nil, :arglists (quote ([m exponent]))}, :protocol clojure.core.matrix.protocols/PExponent, :name clojure.core.matrix.protocols/element-pow, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m exponent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 813, :end-line 818, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m exponent])), :doc nil}, transpose {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 686, :column 4, :end-line 686, :end-column 13, :protocol clojure.core.matrix.protocols/PTranspose, :doc "Returns the transpose of a matrix. Equivalent to reversing the \"shape\".\n     Note that:\n     - The transpose of a scalar is the same scalar\n     - The transpose of a 1D vector is the same 1D vector\n     - The transpose of a 2D matrix swaps rows and columns", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PTranspose, :name clojure.core.matrix.protocols/transpose, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 684, :end-line 686, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the transpose of a matrix. Equivalent to reversing the \"shape\".\n     Note that:\n     - The transpose of a scalar is the same scalar\n     - The transpose of a 1D vector is the same 1D vector\n     - The transpose of a 2D matrix swaps rows and columns"}, PMatrixOps {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 787, :column 14, :end-line 787, :end-column 24, :doc "Protocol to support common 2D numerical matrix operations", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {trace [[m]], determinant [[m]], inverse [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixOps, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 787, :protocol-info {:methods {trace [[m]], determinant [[m]], inverse [[m]]}}, :info nil, :end-line 787, :impls #{}, :doc "Protocol to support common 2D numerical matrix operations", :jsdoc ("@interface")}, get-columns {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 354, :column 4, :end-line 354, :end-column 15, :protocol clojure.core.matrix.protocols/PMatrixColumns, :doc "Returns the columns of a matrix, as a sequence", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixColumns, :name clojure.core.matrix.protocols/get-columns, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 352, :end-line 354, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the columns of a matrix, as a sequence"}, PMatrixDivideMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 576, :column 14, :end-line 576, :end-column 34, :doc "Protocol to support mutable element-wise division operater.\n\n   One-arg version computes the reciprocal of all elements.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {element-divide! [[m] [m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixDivideMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 34, :column 1, :line 576, :protocol-info {:methods {element-divide! [[m] [m a]]}}, :info nil, :end-line 576, :impls #{}, :doc "Protocol to support mutable element-wise division operater.\n\n   One-arg version computes the reciprocal of all elements.", :jsdoc ("@interface")}, PRotateAll {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 699, :column 14, :end-line 699, :end-column 24, :doc "Rotates an array using the specified shifts for each dimension.\n\n   shifts may be any sequence of integer shift amounts.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {rotate-all [[m shifts]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PRotateAll, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 699, :protocol-info {:methods {rotate-all [[m shifts]]}}, :info nil, :end-line 699, :impls #{}, :doc "Rotates an array using the specified shifts for each dimension.\n\n   shifts may be any sequence of integer shift amounts.", :jsdoc ("@interface")}, columns {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1172, :column 4, :end-line 1172, :end-column 11, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :doc "Returns a persistent vector containing columns in the same order they are placed in the dataset", :arglists (quote ([ds]))}, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :name clojure.core.matrix.protocols/columns, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([ds]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1170, :end-line 1172, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ds])), :doc "Returns a persistent vector containing columns in the same order they are placed in the dataset"}, PAddScaledMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 560, :column 14, :end-line 560, :end-column 31, :doc "Protocol for mutable add-scaled! operation.\n\n   Implementations may assume that factor is a scalar.\n\n   Intended to support optimised implementations for m = m + a * factor", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {add-scaled! [[m a factor]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PAddScaledMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 31, :column 1, :line 560, :protocol-info {:methods {add-scaled! [[m a factor]]}}, :info nil, :end-line 560, :impls #{}, :doc "Protocol for mutable add-scaled! operation.\n\n   Implementations may assume that factor is a scalar.\n\n   Intended to support optimised implementations for m = m + a * factor", :jsdoc ("@interface")}, broadcast {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 283, :column 4, :end-line 283, :end-column 13, :protocol clojure.core.matrix.protocols/PBroadcast, :doc "Broadcasts an array over a desired target shape, which should be larger than the current matrix.\n     Dimensions should be matched up according to the last dimension.\n     In order to broadcast sucessfully, the current dimension of the array must be either:\n      - of size 1\n      - equal to the size of the dimension in the target shape\n      - not included in the array (i.e. the target shape has more leading dimensions)\n\n     If broadcasting is not possible, an exception must be thrown.\n\n     Broadcasting may return either a view with replicated element or a new immutable matrix.", :arglists (quote ([m target-shape]))}, :protocol clojure.core.matrix.protocols/PBroadcast, :name clojure.core.matrix.protocols/broadcast, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m target-shape]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 281, :end-line 283, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m target-shape])), :doc "Broadcasts an array over a desired target shape, which should be larger than the current matrix.\n     Dimensions should be matched up according to the last dimension.\n     In order to broadcast sucessfully, the current dimension of the array must be either:\n      - of size 1\n      - equal to the size of the dimension in the target shape\n      - not included in the array (i.e. the target shape has more leading dimensions)\n\n     If broadcasting is not possible, an exception must be thrown.\n\n     Broadcasting may return either a view with replicated element or a new immutable matrix."}, PNonZeroIndices {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1101, :column 14, :end-line 1101, :end-column 29, :doc "Protocol for getting non-zero indices of an array", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {non-zero-indices [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PNonZeroIndices, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :column 1, :line 1101, :protocol-info {:methods {non-zero-indices [[m]]}}, :info nil, :end-line 1101, :impls #{}, :doc "Protocol for getting non-zero indices of an array", :jsdoc ("@interface")}, element-eq {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 971, :column 4, :end-line 971, :end-column 14, :protocol clojure.core.matrix.protocols/PCompare, :doc "Return a binary array or matrix where elements of m equal to a are\n    represented by 1 and elements not-equal to a are represented as 0.", :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PCompare, :name clojure.core.matrix.protocols/element-eq, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 941, :end-line 971, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc "Return a binary array or matrix where elements of m equal to a are\n    represented by 1 and elements not-equal to a are represented as 0."}, zero-matrix? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1037, :column 4, :end-line 1037, :end-column 16, :protocol clojure.core.matrix.protocols/PMatrixPredicates, :doc "Returns true if all the elements of matrix m are zeros", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixPredicates, :name clojure.core.matrix.protocols/zero-matrix?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1032, :end-line 1037, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if all the elements of matrix m are zeros"}, matrix-multiply {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 517, :column 4, :end-line 517, :end-column 19, :protocol clojure.core.matrix.protocols/PMatrixMultiply, :doc nil, :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PMatrixMultiply, :name clojure.core.matrix.protocols/matrix-multiply, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 512, :end-line 517, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc nil}, calc-common-shape {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1203, :column 8, :end-line 1203, :end-column 25, :private true, :arglists (quote ([a b])), :doc "Returns the larger of two shapes if they are compatible, nil otherwise"}, :private true, :name clojure.core.matrix.protocols/calc-common-shape, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1203, :end-line 1203, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :doc "Returns the larger of two shapes if they are compatible, nil otherwise"}, trace {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 789, :column 4, :end-line 789, :end-column 9, :protocol clojure.core.matrix.protocols/PMatrixOps, :doc "Returns the trace of a matrix (sum of elements on main diagonal.\n     Must throw an error if the matrix is not square (i.e. different number of rows and columns)", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixOps, :name clojure.core.matrix.protocols/trace, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 787, :end-line 789, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the trace of a matrix (sum of elements on main diagonal.\n     Must throw an error if the matrix is not square (i.e. different number of rows and columns)"}, PGenericOperations {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1065, :column 14, :end-line 1065, :end-column 32, :doc "Protocol for returning the generic numerical functions of a matrix implementation", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {generic-add [[m]], generic-mul [[m]], generic-negate [[m]], generic-div [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PGenericOperations, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 32, :column 1, :line 1065, :protocol-info {:methods {generic-add [[m]], generic-mul [[m]], generic-negate [[m]], generic-div [[m]]}}, :info nil, :end-line 1065, :impls #{}, :doc "Protocol for returning the generic numerical functions of a matrix implementation", :jsdoc ("@interface")}, PCholeskyDecomposition {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1142, :column 14, :end-line 1142, :end-column 36, :doc "Procotol for Cholesky decomposition", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {cholesky [[m options]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PCholeskyDecomposition, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 36, :column 1, :line 1142, :protocol-info {:methods {cholesky [[m options]]}}, :info nil, :end-line 1142, :impls #{}, :doc "Procotol for Cholesky decomposition", :jsdoc ("@interface")}, norm {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1136, :column 4, :end-line 1136, :end-column 8, :protocol clojure.core.matrix.protocols/PNorm, :doc nil, :arglists (quote ([m p]))}, :protocol clojure.core.matrix.protocols/PNorm, :name clojure.core.matrix.protocols/norm, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m p]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1134, :end-line 1136, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m p])), :doc nil}, get-shape {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 76, :column 4, :end-line 76, :end-column 13, :protocol clojure.core.matrix.protocols/PDimensionInfo, :doc "Returns the shape of the array, typically as a Java array or sequence of dimension sizes.\n     Implementations are free to choose what type is used to represent the shape, but it must\n     contain only integer values and be traversable as a sequence via clojure.core/seq", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PDimensionInfo, :name clojure.core.matrix.protocols/get-shape, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 71, :end-line 76, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the shape of the array, typically as a Java array or sequence of dimension sizes.\n     Implementations are free to choose what type is used to represent the shape, but it must\n     contain only integer values and be traversable as a sequence via clojure.core/seq"}, eigen {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1156, :column 4, :end-line 1156, :end-column 9, :protocol clojure.core.matrix.protocols/PEigenDecomposition, :doc nil, :arglists (quote ([m options]))}, :protocol clojure.core.matrix.protocols/PEigenDecomposition, :name clojure.core.matrix.protocols/eigen, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m options]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1154, :end-line 1156, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m options])), :doc nil}, PSquare {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 820, :column 14, :end-line 820, :end-column 21, :doc "Protocol to support element-wise squaring of a numerical array.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {square [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSquare, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 21, :column 1, :line 820, :protocol-info {:methods {square [[m]]}}, :info nil, :end-line 820, :impls #{}, :doc "Protocol to support element-wise squaring of a numerical array.", :jsdoc ("@interface")}, set-row! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 872, :column 4, :end-line 872, :end-column 12, :protocol clojure.core.matrix.protocols/PRowSetting, :doc nil, :arglists (quote ([m i row]))}, :protocol clojure.core.matrix.protocols/PRowSetting, :name clojure.core.matrix.protocols/set-row!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 12, :method-params ([m i row]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 869, :end-line 872, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m i row])), :doc nil}, matrix-equals-epsilon {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 508, :column 4, :end-line 508, :end-column 25, :protocol clojure.core.matrix.protocols/PMatrixEqualityEpsilon, :doc "As matrix-equals, but provides a numerical tolerance for equality testing.", :arglists (quote ([a b eps]))}, :protocol clojure.core.matrix.protocols/PMatrixEqualityEpsilon, :name clojure.core.matrix.protocols/matrix-equals-epsilon, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :method-params ([a b eps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 503, :end-line 508, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a b eps])), :doc "As matrix-equals, but provides a numerical tolerance for equality testing."}, get-1d {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 94, :column 4, :end-line 94, :end-column 10, :protocol clojure.core.matrix.protocols/PIndexedAccess, :doc nil, :arglists (quote ([m row]))}, :protocol clojure.core.matrix.protocols/PIndexedAccess, :name clojure.core.matrix.protocols/get-1d, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m row]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 91, :end-line 94, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m row])), :doc nil}, PBroadcast {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 281, :column 14, :end-line 281, :end-column 24, :doc "Protocol to support broadcasting over one or more dimensions.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {broadcast [[m target-shape]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PBroadcast, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 281, :protocol-info {:methods {broadcast [[m target-shape]]}}, :info nil, :end-line 281, :impls #{}, :doc "Protocol to support broadcasting over one or more dimensions.", :jsdoc ("@interface")}, PNumerical {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 736, :column 14, :end-line 736, :end-column 24, :doc "Protocol for identifying numerical arrays. Should return true if every element in the\n   array is guaranteed to be a valid numerical value.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {numerical? [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PNumerical, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 736, :protocol-info {:methods {numerical? [[m]]}}, :info nil, :end-line 736, :impls #{}, :doc "Protocol for identifying numerical arrays. Should return true if every element in the\n   array is guaranteed to be a valid numerical value.", :jsdoc ("@interface")}, PMatrixEqualityEpsilon {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 503, :column 14, :end-line 503, :end-column 36, :doc "Protocol for numerical array equality operations with a specified tolerance. Arrays are defined as equal\n   if the array shapes are the same and and for all corresponding elements ai and bi we have: |ai-bi|<=eps\n\n   Should be equivalent to PMatrixEquality when eps is zero.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {matrix-equals-epsilon [[a b eps]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixEqualityEpsilon, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 36, :column 1, :line 503, :protocol-info {:methods {matrix-equals-epsilon [[a b eps]]}}, :info nil, :end-line 503, :impls #{}, :doc "Protocol for numerical array equality operations with a specified tolerance. Arrays are defined as equal\n   if the array shapes are the same and and for all corresponding elements ai and bi we have: |ai-bi|<=eps\n\n   Should be equivalent to PMatrixEquality when eps is zero.", :jsdoc ("@interface")}, gemm! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 980, :column 4, :end-line 980, :end-column 9, :protocol clojure.core.matrix.protocols/PBLASBase, :doc nil, :arglists (quote ([c trans-a? trans-b? alpha a b beta]))}, :protocol clojure.core.matrix.protocols/PBLASBase, :name clojure.core.matrix.protocols/gemm!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([c trans-a? trans-b? alpha a b beta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 975, :end-line 980, :max-fixed-arity 7, :fn-var true, :arglists (quote ([c trans-a? trans-b? alpha a b beta])), :doc nil}, PImmutableAssignment {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 452, :column 14, :end-line 452, :end-column 34, :doc "Protocol for assigning values element-wise to an array, broadcasting as needed.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {assign [[m source]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PImmutableAssignment, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 34, :column 1, :line 452, :protocol-info {:methods {assign [[m source]]}}, :info nil, :end-line 452, :impls #{}, :doc "Protocol for assigning values element-wise to an array, broadcasting as needed.", :jsdoc ("@interface")}, exp {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 889, :column 4, :end-line 889, :end-column 7, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/exp, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 7, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 889, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PBroadcastLike {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 295, :column 14, :end-line 295, :end-column 28, :doc "Protocol to broadcast into a given matrix shape. May also perform coercion if needed by the implementation.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {broadcast-like [[m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PBroadcastLike, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 295, :protocol-info {:methods {broadcast-like [[m a]]}}, :info nil, :end-line 295, :impls #{}, :doc "Protocol to broadcast into a given matrix shape. May also perform coercion if needed by the implementation.", :jsdoc ("@interface")}, PAddProductMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 532, :column 14, :end-line 532, :end-column 32, :doc "Optional protocol for mutable add-product! operation.\n\n   Intended to support optimised implementations for m = m + a * b", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {add-product! [[m a b]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PAddProductMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 32, :column 1, :line 532, :protocol-info {:methods {add-product! [[m a b]]}}, :info nil, :end-line 532, :impls #{}, :doc "Optional protocol for mutable add-product! operation.\n\n   Intended to support optimised implementations for m = m + a * b", :jsdoc ("@interface")}, PIndexedAccess {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 91, :column 14, :end-line 91, :end-column 28, :doc "Protocol for indexed read access to arrays, matrices and vectors. Indexing values can\n   be assumed to be integers. indexes may be any sequence or Java array of index values.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {get-1d [[m row]], get-2d [[m row column]], get-nd [[m indexes]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PIndexedAccess, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 91, :protocol-info {:methods {get-1d [[m row]], get-2d [[m row column]], get-nd [[m indexes]]}}, :info nil, :end-line 91, :impls #{}, :doc "Protocol for indexed read access to arrays, matrices and vectors. Indexing values can\n   be assumed to be integers. indexes may be any sequence or Java array of index values.", :jsdoc ("@interface")}, PMatrixMultiply {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 512, :column 14, :end-line 512, :end-column 29, :doc "Protocol to support matrix multiplication on numerical arrays.\n\n   Implementation may return nil if the implementation does not support one of the parameters, in\n   which case a more general operation will be attempted.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {matrix-multiply [[m a]], element-multiply [[m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixMultiply, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :column 1, :line 512, :protocol-info {:methods {matrix-multiply [[m a]], element-multiply [[m a]]}}, :info nil, :end-line 512, :impls #{}, :doc "Protocol to support matrix multiplication on numerical arrays.\n\n   Implementation may return nil if the implementation does not support one of the parameters, in\n   which case a more general operation will be attempted.", :jsdoc ("@interface")}, PMatrixMultiplyMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 584, :column 14, :end-line 584, :end-column 36, :doc "Protocol to support mutable matrix multiplication on an arbitrary matrix, vector or scalar", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {matrix-multiply! [[m a]], element-multiply! [[m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixMultiplyMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 36, :column 1, :line 584, :protocol-info {:methods {matrix-multiply! [[m a]], element-multiply! [[m a]]}}, :info nil, :end-line 584, :impls #{}, :doc "Protocol to support mutable matrix multiplication on an arbitrary matrix, vector or scalar", :jsdoc ("@interface")}, rank {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 805, :column 4, :end-line 805, :end-column 8, :protocol clojure.core.matrix.protocols/PMatrixRank, :doc "Returns the rank of a matrix", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixRank, :name clojure.core.matrix.protocols/rank, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 803, :end-line 805, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the rank of a matrix"}, matrix-add {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 618, :column 4, :end-line 618, :end-column 14, :protocol clojure.core.matrix.protocols/PMatrixAdd, :doc nil, :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PMatrixAdd, :name clojure.core.matrix.protocols/matrix-add, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 615, :end-line 618, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc nil}, fill! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 460, :column 4, :end-line 460, :end-column 9, :protocol clojure.core.matrix.protocols/PMutableFill, :doc "Fills the array with the given scalar value.", :arglists (quote ([m value]))}, :protocol clojure.core.matrix.protocols/PMutableFill, :name clojure.core.matrix.protocols/fill!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 459, :end-line 460, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m value])), :doc "Fills the array with the given scalar value."}, get-slice-seq {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 389, :column 4, :end-line 389, :end-column 17, :protocol clojure.core.matrix.protocols/PSliceSeq2, :doc "Gets a sequence of all array slices", :arglists (quote ([m dim]))}, :protocol clojure.core.matrix.protocols/PSliceSeq2, :name clojure.core.matrix.protocols/get-slice-seq, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([m dim]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 384, :end-line 389, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m dim])), :doc "Gets a sequence of all array slices"}, length-squared {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 755, :column 4, :end-line 755, :end-column 18, :protocol clojure.core.matrix.protocols/PVectorOps, :doc "Squared Euclidean length of a vector.", :arglists (quote ([a]))}, :protocol clojure.core.matrix.protocols/PVectorOps, :name clojure.core.matrix.protocols/length-squared, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 742, :end-line 755, :max-fixed-arity 1, :fn-var true, :arglists (quote ([a])), :doc "Squared Euclidean length of a vector."}, element-map-indexed {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1014, :column 4, :end-line 1014, :end-column 23, :protocol clojure.core.matrix.protocols/PMapIndexed, :doc "Maps f over all elements of m (and optionally other matrices), returning a new matrix.\n     f is expected to accept an index vector and the current element value, and produce\n     elements of a type supported by the implementation of m - failure\n     to do so may cause an error.", :arglists (quote ([m f] [m f a] [m f a more])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m f] [m f a] [m f a more]), :arglists ([m f] [m f a] [m f a more]), :arglists-meta (nil nil nil)}}, :protocol clojure.core.matrix.protocols/PMapIndexed, :name clojure.core.matrix.protocols/element-map-indexed, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m f] [m f a] [m f a more]), :arglists ([m f] [m f a] [m f a more]), :arglists-meta (nil nil nil)}, :method-params ([m f] [m f a] [m f a more]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1010, :end-line 1014, :max-fixed-arity 4, :fn-var true, :arglists ([m f] [m f a] [m f a more]), :doc "Maps f over all elements of m (and optionally other matrices), returning a new matrix.\n     f is expected to accept an index vector and the current element value, and produce\n     elements of a type supported by the implementation of m - failure\n     to do so may cause an error."}, add-scaled-product! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 550, :column 4, :end-line 550, :end-column 23, :protocol clojure.core.matrix.protocols/PAddScaledProductMutable, :doc nil, :arglists (quote ([m a b factor]))}, :protocol clojure.core.matrix.protocols/PAddScaledProductMutable, :name clojure.core.matrix.protocols/add-scaled-product!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :method-params ([m a b factor]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 546, :end-line 550, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m a b factor])), :doc nil}, PVectorView {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 770, :column 14, :end-line 770, :end-column 25, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {as-vector [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PVectorView, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :column 1, :line 770, :protocol-info {:methods {as-vector [[m]]}}, :info nil, :end-line 770, :impls #{}, :doc nil, :jsdoc ("@interface")}, mutable-matrix {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 181, :column 4, :end-line 181, :end-column 18, :protocol clojure.core.matrix.protocols/PMutableMatrixConstruction, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMutableMatrixConstruction, :name clojure.core.matrix.protocols/mutable-matrix, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 176, :end-line 181, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, add-product! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 536, :column 4, :end-line 536, :end-column 16, :protocol clojure.core.matrix.protocols/PAddProductMutable, :doc "Adds the elementwise product of a and b to m", :arglists (quote ([m a b]))}, :protocol clojure.core.matrix.protocols/PAddProductMutable, :name clojure.core.matrix.protocols/add-product!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :method-params ([m a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 532, :end-line 536, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m a b])), :doc "Adds the elementwise product of a and b to m"}, lower-triangular? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1047, :column 4, :end-line 1047, :end-column 21, :protocol clojure.core.matrix.protocols/PMatrixTypes, :doc "Returns true if the matrix m is lower triangualar", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixTypes, :name clojure.core.matrix.protocols/lower-triangular?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 21, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1044, :end-line 1047, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if the matrix m is lower triangualar"}, add-outer-product! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 658, :column 4, :end-line 658, :end-column 22, :protocol clojure.core.matrix.protocols/PAddOuterProductMutable, :doc "Adds the outer product of a, b and an optional scalar factor to m", :arglists (quote ([m a b] [m a b factor])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m a b] [m a b factor]), :arglists ([m a b] [m a b factor]), :arglists-meta (nil nil)}}, :protocol clojure.core.matrix.protocols/PAddOuterProductMutable, :name clojure.core.matrix.protocols/add-outer-product!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 22, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m a b] [m a b factor]), :arglists ([m a b] [m a b factor]), :arglists-meta (nil nil)}, :method-params ([m a b] [m a b factor]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 654, :end-line 658, :max-fixed-arity 4, :fn-var true, :arglists ([m a b] [m a b factor]), :doc "Adds the outer product of a, b and an optional scalar factor to m"}, broadcast-same-shape {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1243, :column 7, :end-line 1243, :end-column 27, :arglists (quote ([a b])), :doc "Broadcasts two matrices into identical shapes. Intended to prepare for elementwise operations.\n   Returns a vector containing the two broadcasted matrices.\n   Throws an error if not possible."}, :name clojure.core.matrix.protocols/broadcast-same-shape, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 27, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1243, :end-line 1243, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :doc "Broadcasts two matrices into identical shapes. Intended to prepare for elementwise operations.\n   Returns a vector containing the two broadcasted matrices.\n   Throws an error if not possible."}, determinant {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 792, :column 4, :end-line 792, :end-column 15, :protocol clojure.core.matrix.protocols/PMatrixOps, :doc "Returns the determinant of a matrix. May return nil if the implementation is unable\n     to compute determinants.\n     Must throw an error if the matrix is not square (i.e. different number of rows and columns)", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixOps, :name clojure.core.matrix.protocols/determinant, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 787, :end-line 792, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the determinant of a matrix. May return nil if the implementation is unable\n     to compute determinants.\n     Must throw an error if the matrix is not square (i.e. different number of rows and columns)"}, PRowColMatrix {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 167, :column 14, :end-line 167, :end-column 27, :doc "Protocol to support construction of row and column matrices from 1D vectors.\n\n   A vector of length N should be converted to a 1xN or Nx1 matrix respectively.\n\n   Should throw an error if the data is not a 1D vector", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {column-matrix [[m data]], row-matrix [[m data]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PRowColMatrix, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 27, :column 1, :line 167, :protocol-info {:methods {column-matrix [[m data]], row-matrix [[m data]]}}, :info nil, :end-line 167, :impls #{}, :doc "Protocol to support construction of row and column matrices from 1D vectors.\n\n   A vector of length N should be converted to a 1xN or Nx1 matrix respectively.\n\n   Should throw an error if the data is not a 1D vector", :jsdoc ("@interface")}, PMatrixTypes {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1044, :column 14, :end-line 1044, :end-column 26, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {diagonal? [[m]], upper-triangular? [[m]], lower-triangular? [[m]], positive-definite? [[m]], positive-semidefinite? [[m]], orthogonal? [[m eps]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixTypes, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 26, :column 1, :line 1044, :protocol-info {:methods {diagonal? [[m]], upper-triangular? [[m]], lower-triangular? [[m]], positive-definite? [[m]], positive-semidefinite? [[m]], orthogonal? [[m eps]]}}, :info nil, :end-line 1044, :impls #{}, :doc nil, :jsdoc ("@interface")}, cosh {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 888, :column 4, :end-line 888, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/cosh, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 888, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, scale-add! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 630, :column 4, :end-line 630, :end-column 14, :protocol clojure.core.matrix.protocols/PScaleAdd, :doc "Scales array m1 in place by factor b, then adds array m2 scaled by factor b, then adds the constant", :arglists (quote ([m1 a m2 b constant]))}, :protocol clojure.core.matrix.protocols/PScaleAdd, :name clojure.core.matrix.protocols/scale-add!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m1 a m2 b constant]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 626, :end-line 630, :max-fixed-arity 5, :fn-var true, :arglists (quote ([m1 a m2 b constant])), :doc "Scales array m1 in place by factor b, then adds array m2 scaled by factor b, then adds the constant"}, PDimensionInfo {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 71, :column 14, :end-line 71, :end-column 28, :doc "Protocol to return standard dimension information about an array.\n   dimensionality and dimension-count are mandatory for implementations", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {dimensionality [[m]], get-shape [[m]], is-scalar? [[m]], is-vector? [[m]], dimension-count [[m dimension-number]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PDimensionInfo, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 71, :protocol-info {:methods {dimensionality [[m]], get-shape [[m]], is-scalar? [[m]], is-vector? [[m]], dimension-count [[m dimension-number]]}}, :info nil, :end-line 71, :impls #{}, :doc "Protocol to return standard dimension information about an array.\n   dimensionality and dimension-count are mandatory for implementations", :jsdoc ("@interface")}, set-1d {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 102, :column 4, :end-line 102, :end-column 10, :protocol clojure.core.matrix.protocols/PIndexedSetting, :doc nil, :arglists (quote ([m row v]))}, :protocol clojure.core.matrix.protocols/PIndexedSetting, :name clojure.core.matrix.protocols/set-1d, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m row v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 102, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m row v])), :doc nil}, PMutableVectorOps {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 783, :column 14, :end-line 783, :end-column 31, :doc "Protocol for mutable versions of common vector operations", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {normalise! [[a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMutableVectorOps, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 31, :column 1, :line 783, :protocol-info {:methods {normalise! [[a]]}}, :info nil, :end-line 783, :impls #{}, :doc "Protocol for mutable versions of common vector operations", :jsdoc ("@interface")}, upper-triangular? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1046, :column 4, :end-line 1046, :end-column 21, :protocol clojure.core.matrix.protocols/PMatrixTypes, :doc "Returns true if the matrix m is upper triangualar", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixTypes, :name clojure.core.matrix.protocols/upper-triangular?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 21, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1044, :end-line 1046, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if the matrix m is upper triangualar"}, native? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 207, :column 4, :end-line 207, :end-column 11, :protocol clojure.core.matrix.protocols/PNative, :doc "Returns true if an array is in a native format, false otherwise.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PNative, :name clojure.core.matrix.protocols/native?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 203, :end-line 207, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if an array is in a native format, false otherwise."}, join-along {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 405, :column 4, :end-line 405, :end-column 14, :protocol clojure.core.matrix.protocols/PSliceJoinAlong, :doc "Concatenates a to m, along the slice dimension dim", :arglists (quote ([m a dim]))}, :protocol clojure.core.matrix.protocols/PSliceJoinAlong, :name clojure.core.matrix.protocols/join-along, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m a dim]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 403, :end-line 405, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m a dim])), :doc "Concatenates a to m, along the slice dimension dim"}, assign-array! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 447, :column 4, :end-line 447, :end-column 17, :protocol clojure.core.matrix.protocols/PAssignment, :doc "Sets the elements in an array from a Java array source, in row-major order.", :arglists (quote ([m arr] [m arr start length])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m arr] [m arr start length]), :arglists ([m arr] [m arr start length]), :arglists-meta (nil nil)}}, :protocol clojure.core.matrix.protocols/PAssignment, :name clojure.core.matrix.protocols/assign-array!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m arr] [m arr start length]), :arglists ([m arr] [m arr start length]), :arglists-meta (nil nil)}, :method-params ([m arr] [m arr start length]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 441, :end-line 447, :max-fixed-arity 4, :fn-var true, :arglists ([m arr] [m arr start length]), :doc "Sets the elements in an array from a Java array source, in row-major order."}, PValueEquality {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 486, :column 14, :end-line 486, :end-column 28, :doc "Protocol for comparing two arrays, with the semantics of clojure.core/=.\n   Must return false if the arrays are not of equal shape, or if any elements are not equal.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {value-equals [[m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PValueEquality, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 486, :protocol-info {:methods {value-equals [[m a]]}}, :info nil, :end-line 486, :impls #{}, :doc "Protocol for comparing two arrays, with the semantics of clojure.core/=.\n   Must return false if the arrays are not of equal shape, or if any elements are not equal.", :jsdoc ("@interface")}, PSolveLinear {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1158, :column 14, :end-line 1158, :end-column 26, :doc "Protocol for solving linear matrix equation or system of linear scalar equations", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {solve [[a b]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSolveLinear, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 26, :column 1, :line 1158, :protocol-info {:methods {solve [[a b]]}}, :info nil, :end-line 1158, :impls #{}, :doc "Protocol for solving linear matrix equation or system of linear scalar equations", :jsdoc ("@interface")}, broadcast-like {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 297, :column 4, :end-line 297, :end-column 18, :protocol clojure.core.matrix.protocols/PBroadcastLike, :doc nil, :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PBroadcastLike, :name clojure.core.matrix.protocols/broadcast-like, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 295, :end-line 297, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc nil}, get-major-slice {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 343, :column 4, :end-line 343, :end-column 19, :protocol clojure.core.matrix.protocols/PMatrixSlices, :doc "Gets the major slice of an array with the given index. For a 2D matrix, equivalent to get-row", :arglists (quote ([m i]))}, :protocol clojure.core.matrix.protocols/PMatrixSlices, :name clojure.core.matrix.protocols/get-major-slice, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([m i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 336, :end-line 343, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m i])), :doc "Gets the major slice of an array with the given index. For a 2D matrix, equivalent to get-row"}, row-maps {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1177, :column 4, :end-line 1177, :end-column 12, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :doc "Returns seq of maps with row values", :arglists (quote ([ds]))}, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :name clojure.core.matrix.protocols/row-maps, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 12, :method-params ([ds]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1170, :end-line 1177, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ds])), :doc "Returns seq of maps with row values"}, PAssignment {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 441, :column 14, :end-line 441, :end-column 25, :doc "Protocol for assigning values element-wise to mutable arrays.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {assign! [[m source]], assign-array! [[m arr] [m arr start length]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PAssignment, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :column 1, :line 441, :protocol-info {:methods {assign! [[m source]], assign-array! [[m arr] [m arr start length]]}}, :info nil, :end-line 441, :impls #{}, :doc "Protocol for assigning values element-wise to mutable arrays.", :jsdoc ("@interface")}, PSliceJoinAlong {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 403, :column 14, :end-line 403, :end-column 29, :doc "Protocol for concatenating / joining arrays.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {join-along [[m a dim]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSliceJoinAlong, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :column 1, :line 403, :protocol-info {:methods {join-along [[m a dim]]}}, :info nil, :end-line 403, :impls #{}, :doc "Protocol for concatenating / joining arrays.", :jsdoc ("@interface")}, element-if {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 946, :column 4, :end-line 946, :end-column 14, :protocol clojure.core.matrix.protocols/PCompare, :doc "Element-wise if statement.\n\n    Traverse each element, x, of a array or matrix, m. If:\n      - x > 0, return a (if scalar) or corresponding element of a (if a is an\n        array or matrix with same shape shape as m).\n      - x <= 0, return b (if scalar) or corresponding element in b (if b is an\n        array or matrix with same shape shape as m).\n\n    Return an array or matrix with the same shape as m.", :arglists (quote ([m a b]))}, :protocol clojure.core.matrix.protocols/PCompare, :name clojure.core.matrix.protocols/element-if, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 941, :end-line 946, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m a b])), :doc "Element-wise if statement.\n\n    Traverse each element, x, of a array or matrix, m. If:\n      - x > 0, return a (if scalar) or corresponding element of a (if a is an\n        array or matrix with same shape shape as m).\n      - x <= 0, return b (if scalar) or corresponding element in b (if b is an\n        array or matrix with same shape shape as m).\n\n    Return an array or matrix with the same shape as m."}, get-indices {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1094, :column 4, :end-line 1094, :end-column 15, :protocol clojure.core.matrix.protocols/PIndicesAccess, :doc "returns a 1-d array with the elements of a at indices", :arglists (quote ([a indices]))}, :protocol clojure.core.matrix.protocols/PIndicesAccess, :name clojure.core.matrix.protocols/get-indices, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([a indices]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1092, :end-line 1094, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a indices])), :doc "returns a 1-d array with the elements of a at indices"}, PMatrixAddMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 621, :column 14, :end-line 621, :end-column 31, :doc "Protocol to support mutable addition and subtraction", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {matrix-add! [[m a]], matrix-sub! [[m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixAddMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 31, :column 1, :line 621, :protocol-info {:methods {matrix-add! [[m a]], matrix-sub! [[m a]]}}, :info nil, :end-line 621, :impls #{}, :doc "Protocol to support mutable addition and subtraction", :jsdoc ("@interface")}, get-major-slice-seq {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 381, :column 4, :end-line 381, :end-column 23, :protocol clojure.core.matrix.protocols/PSliceSeq, :doc "Gets a sequence of all major array slices", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PSliceSeq, :name clojure.core.matrix.protocols/get-major-slice-seq, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 374, :end-line 381, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Gets a sequence of all major array slices"}, generic-zero {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1061, :column 4, :end-line 1061, :end-column 16, :protocol clojure.core.matrix.protocols/PGenericValues, :doc "Generic 'zero' value for numerical arrays. Must satisfy (equals m (add m zero)).", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PGenericValues, :name clojure.core.matrix.protocols/generic-zero, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1059, :end-line 1061, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Generic 'zero' value for numerical arrays. Must satisfy (equals m (add m zero))."}, PDimensionLabels {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1119, :column 14, :end-line 1119, :end-column 30, :doc "Protocol for arrays supporting labelled dimensions", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {label [[m dim i]], labels [[m dim]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PDimensionLabels, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 30, :column 1, :line 1119, :protocol-info {:methods {label [[m dim i]], labels [[m dim]]}}, :info nil, :end-line 1119, :impls #{}, :doc "Protocol for arrays supporting labelled dimensions", :jsdoc ("@interface")}, solve {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1160, :column 4, :end-line 1160, :end-column 9, :protocol clojure.core.matrix.protocols/PSolveLinear, :doc nil, :arglists (quote ([a b]))}, :protocol clojure.core.matrix.protocols/PSolveLinear, :name clojure.core.matrix.protocols/solve, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1158, :end-line 1160, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :doc nil}, PObjectArrayOutput {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 475, :column 14, :end-line 475, :end-column 32, :doc "Protocol for getting element data as a flattened object array", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {to-object-array [[m]], as-object-array [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PObjectArrayOutput, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 32, :column 1, :line 475, :protocol-info {:methods {to-object-array [[m]], as-object-array [[m]]}}, :info nil, :end-line 475, :impls #{}, :doc "Protocol for getting element data as a flattened object array", :jsdoc ("@interface")}, outer-product {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 524, :column 4, :end-line 524, :end-column 17, :protocol clojure.core.matrix.protocols/PMatrixProducts, :doc "Returns the outer product of two numerical arrays.", :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PMatrixProducts, :name clojure.core.matrix.protocols/outer-product, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 520, :end-line 524, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc "Returns the outer product of two numerical arrays."}, element-divide {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 572, :column 4, :end-line 572, :end-column 18, :protocol clojure.core.matrix.protocols/PMatrixDivide, :doc nil, :arglists (quote ([m] [m a])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([m] [m a]), :arglists ([m] [m a]), :arglists-meta (nil nil)}}, :protocol clojure.core.matrix.protocols/PMatrixDivide, :name clojure.core.matrix.protocols/element-divide, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([m] [m a]), :arglists ([m] [m a]), :arglists-meta (nil nil)}, :method-params ([m] [m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 568, :end-line 572, :max-fixed-arity 2, :fn-var true, :arglists ([m] [m a]), :doc nil}, nonzero-count {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 157, :column 4, :end-line 157, :end-column 17, :protocol clojure.core.matrix.protocols/PArrayMetrics, :doc "Returns the number of non-zero values in a numerical array. May throw an exception if the array is not numerical.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PArrayMetrics, :name clojure.core.matrix.protocols/nonzero-count, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 155, :end-line 157, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the number of non-zero values in a numerical array. May throw an exception if the array is not numerical."}, cross-product {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 761, :column 4, :end-line 761, :end-column 17, :protocol clojure.core.matrix.protocols/PVectorCross, :doc "Cross product of two vectors", :arglists (quote ([a b]))}, :protocol clojure.core.matrix.protocols/PVectorCross, :name clojure.core.matrix.protocols/cross-product, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 760, :end-line 761, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :doc "Cross product of two vectors"}, PBroadcastCoerce {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 299, :column 14, :end-line 299, :end-column 30, :doc "Protocol to broadcast into a given matrix shape and perform coercion in one step.\n\n   Equivalent to (coerce m (broadcast-like m a)) but likely to be more efficient.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {broadcast-coerce [[m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PBroadcastCoerce, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 30, :column 1, :line 299, :protocol-info {:methods {broadcast-coerce [[m a]]}}, :info nil, :end-line 299, :impls #{}, :doc "Protocol to broadcast into a given matrix shape and perform coercion in one step.\n\n   Equivalent to (coerce m (broadcast-like m a)) but likely to be more efficient.", :jsdoc ("@interface")}, same-shapes? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1255, :column 7, :end-line 1255, :end-column 19, :arglists (quote ([arrays])), :doc "Returns truthy if a sequence of arrays all have the same shape."}, :name clojure.core.matrix.protocols/same-shapes?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([arrays]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1255, :end-line 1255, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arrays])), :doc "Returns truthy if a sequence of arrays all have the same shape."}, generic-one {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1062, :column 4, :end-line 1062, :end-column 15, :protocol clojure.core.matrix.protocols/PGenericValues, :doc "Generic 'one' value for numerical arrays. Must satisfy (equals m (mul m one)).", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PGenericValues, :name clojure.core.matrix.protocols/generic-one, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1059, :end-line 1062, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Generic 'one' value for numerical arrays. Must satisfy (equals m (mul m one))."}, PIndexedSettingMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 114, :column 14, :end-line 114, :end-column 36, :doc "Protocol for indexed mutable setter access to matrices and vectors.\n   Must be supported for any mutable matrix type.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {set-1d! [[m row v]], set-2d! [[m row column v]], set-nd! [[m indexes v]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PIndexedSettingMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 36, :column 1, :line 114, :protocol-info {:methods {set-1d! [[m row v]], set-2d! [[m row column v]], set-nd! [[m indexes v]]}}, :info nil, :end-line 114, :impls #{}, :doc "Protocol for indexed mutable setter access to matrices and vectors.\n   Must be supported for any mutable matrix type.", :jsdoc ("@interface")}, gemv! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 981, :column 4, :end-line 981, :end-column 9, :protocol clojure.core.matrix.protocols/PBLASBase, :doc nil, :arglists (quote ([c trans-a? alpha a b beta]))}, :protocol clojure.core.matrix.protocols/PBLASBase, :name clojure.core.matrix.protocols/gemv!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([c trans-a? alpha a b beta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 975, :end-line 981, :max-fixed-arity 6, :fn-var true, :arglists (quote ([c trans-a? alpha a b beta])), :doc nil}, set-0d {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 242, :column 4, :end-line 242, :end-column 10, :protocol clojure.core.matrix.protocols/PZeroDimensionSet, :doc "Sets the scalar value in a 0-d array, returning a new 0-d array", :arglists (quote ([m value]))}, :protocol clojure.core.matrix.protocols/PZeroDimensionSet, :name clojure.core.matrix.protocols/set-0d, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 240, :end-line 242, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m value])), :doc "Sets the scalar value in a 0-d array, returning a new 0-d array"}, PMutableMatrixConstruction {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 176, :column 14, :end-line 176, :end-column 40, :doc "Protocol for creating a mutable copy of a matrix. If implemented, must return either a fully mutable\n   copy of the given matrix, or nil if not possible.\n\n   The default implementation will attempt to choose a suitable mutable matrix implementation.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {mutable-matrix [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMutableMatrixConstruction, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 40, :column 1, :line 176, :protocol-info {:methods {mutable-matrix [[m]]}}, :info nil, :end-line 176, :impls #{}, :doc "Protocol for creating a mutable copy of a matrix. If implemented, must return either a fully mutable\n   copy of the given matrix, or nil if not possible.\n\n   The default implementation will attempt to choose a suitable mutable matrix implementation.", :jsdoc ("@interface")}, PIndexedSetting {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 98, :column 14, :end-line 98, :end-column 29, :doc "Protocol for indexed 'setter' operations. These are like Clojure's 'assoc'\n   function, i.e. they return an updated copy of the original array, which is itself unchanged.\n   Should be supported for any immutable array type.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {set-1d [[m row v]], set-2d [[m row column v]], set-nd [[m indexes v]], is-mutable? [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PIndexedSetting, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :column 1, :line 98, :protocol-info {:methods {set-1d [[m row v]], set-2d [[m row column v]], set-nd [[m indexes v]], is-mutable? [[m]]}}, :info nil, :end-line 98, :impls #{}, :doc "Protocol for indexed 'setter' operations. These are like Clojure's 'assoc'\n   function, i.e. they return an updated copy of the original array, which is itself unchanged.\n   Should be supported for any immutable array type.", :jsdoc ("@interface")}, PDoubleArrayOutput {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 464, :column 14, :end-line 464, :end-column 32, :doc "Protocol for getting element data as a flattened double array", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {to-double-array [[m]], as-double-array [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PDoubleArrayOutput, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 32, :column 1, :line 464, :protocol-info {:methods {to-double-array [[m]], as-double-array [[m]]}}, :info nil, :end-line 464, :impls #{}, :doc "Protocol for getting element data as a flattened double array", :jsdoc ("@interface")}, PMatrixProducts {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 520, :column 14, :end-line 520, :end-column 29, :doc "Protocol for general inner and outer products of numerical arrays.\n   Products should use + and * as normally defined for numerical types", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {inner-product [[m a]], outer-product [[m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixProducts, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :column 1, :line 520, :protocol-info {:methods {inner-product [[m a]], outer-product [[m a]]}}, :info nil, :end-line 520, :impls #{}, :doc "Protocol for general inner and outer products of numerical arrays.\n   Products should use + and * as normally defined for numerical types", :jsdoc ("@interface")}, PSliceSeq2 {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 384, :column 14, :end-line 384, :end-column 24, :doc "Returns slices of the array as a sequence.\n\n   These must be views or immutable sub-arrays for higher order slices, or scalars\n   for the slices of a 1D vector.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {get-slice-seq [[m dim]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSliceSeq2, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 384, :protocol-info {:methods {get-slice-seq [[m dim]]}}, :info nil, :end-line 384, :impls #{}, :doc "Returns slices of the array as a sequence.\n\n   These must be views or immutable sub-arrays for higher order slices, or scalars\n   for the slices of a 1D vector.", :jsdoc ("@interface")}, PSliceView {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 356, :column 14, :end-line 356, :end-column 24, :doc "Protocol for quick view access into a row-major slices of an array. If implemented, must return\n   either a view or an immutable sub-matrix: it must *not* return copied data.\n\n   If the matrix is mutable, it must return a mutable view.\n\n   The default implementation creates a wrapper view.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {get-major-slice-view [[m i]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSliceView, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 356, :protocol-info {:methods {get-major-slice-view [[m i]]}}, :info nil, :end-line 356, :impls #{}, :doc "Protocol for quick view access into a row-major slices of an array. If implemented, must return\n   either a view or an immutable sub-matrix: it must *not* return copied data.\n\n   If the matrix is mutable, it must return a mutable view.\n\n   The default implementation creates a wrapper view.", :jsdoc ("@interface")}, row-matrix {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 174, :column 4, :end-line 174, :end-column 14, :protocol clojure.core.matrix.protocols/PRowColMatrix, :doc nil, :arglists (quote ([m data]))}, :protocol clojure.core.matrix.protocols/PRowColMatrix, :name clojure.core.matrix.protocols/row-matrix, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m data]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 167, :end-line 174, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m data])), :doc nil}, element-gt {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 962, :column 4, :end-line 962, :end-column 14, :protocol clojure.core.matrix.protocols/PCompare, :doc "Return a binary array or matrix where elements of m greater-than a are\n    represented by 1 and elements less-than a are represented as 0.", :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PCompare, :name clojure.core.matrix.protocols/element-gt, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 941, :end-line 962, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc "Return a binary array or matrix where elements of m greater-than a are\n    represented by 1 and elements less-than a are represented as 0."}, cross-product! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 763, :column 4, :end-line 763, :end-column 18, :protocol clojure.core.matrix.protocols/PVectorCross, :doc "Calculate cross product of two vectors, storing the result in the first vector", :arglists (quote ([a b]))}, :protocol clojure.core.matrix.protocols/PVectorCross, :name clojure.core.matrix.protocols/cross-product!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 760, :end-line 763, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :doc "Calculate cross product of two vectors, storing the result in the first vector"}, round! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 917, :column 4, :end-line 917, :end-column 10, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/round!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 917, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, symmetric? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1040, :column 4, :end-line 1040, :end-column 14, :protocol clojure.core.matrix.protocols/PMatrixPredicates, :doc "Returns true if matrix m is symmetric", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixPredicates, :name clojure.core.matrix.protocols/symmetric?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1032, :end-line 1040, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if matrix m is symmetric"}, asin {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 883, :column 4, :end-line 883, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/asin, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 883, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, lerp {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 640, :column 4, :end-line 640, :end-column 8, :protocol clojure.core.matrix.protocols/PLerp, :doc "Linear interpolation: Scales array a by (1-factor), then adds array b scaled by factor.", :arglists (quote ([a b factor]))}, :protocol clojure.core.matrix.protocols/PLerp, :name clojure.core.matrix.protocols/lerp, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([a b factor]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 638, :end-line 640, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a b factor])), :doc "Linear interpolation: Scales array a by (1-factor), then adds array b scaled by factor."}, PMatrixRank {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 803, :column 14, :end-line 803, :end-column 25, :doc "Protocol to support computing the rank (number of linearly independent rows) in a matrix", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {rank [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixRank, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :column 1, :line 803, :protocol-info {:methods {rank [[m]]}}, :info nil, :end-line 803, :impls #{}, :doc "Protocol to support computing the rank (number of linearly independent rows) in a matrix", :jsdoc ("@interface")}, select-view {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1085, :column 4, :end-line 1085, :end-column 15, :protocol clojure.core.matrix.protocols/PSelectView, :doc "selects all elements at indices which are in the cartesian product of args", :arglists (quote ([a args]))}, :protocol clojure.core.matrix.protocols/PSelectView, :name clojure.core.matrix.protocols/select-view, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([a args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1080, :end-line 1085, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a args])), :doc "selects all elements at indices which are in the cartesian product of args"}, PSetSelection {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1087, :column 14, :end-line 1087, :end-column 27, :doc "Protocol for setting the elements of an array returned by (select a args) to values.\n   See the docstring for clojure.core.matrix/select for more information on possible argument values.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {set-selection [[a args values]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSetSelection, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 27, :column 1, :line 1087, :protocol-info {:methods {set-selection [[a args values]]}}, :info nil, :end-line 1087, :impls #{}, :doc "Protocol for setting the elements of an array returned by (select a args) to values.\n   See the docstring for clojure.core.matrix/select for more information on possible argument values.", :jsdoc ("@interface")}, common-shape {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1218, :column 7, :end-line 1218, :end-column 19, :arglists (quote ([shapes])), :doc "Returns the common shape that can be broadcast to from all the shapes specified,\n   or nil if such a shape does not exist."}, :name clojure.core.matrix.protocols/common-shape, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([shapes]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1218, :end-line 1218, :max-fixed-arity 1, :fn-var true, :arglists (quote ([shapes])), :doc "Returns the common shape that can be broadcast to from all the shapes specified,\n   or nil if such a shape does not exist."}, PTypeInfo {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 149, :column 14, :end-line 149, :end-column 23, :doc "Protocol for querying the type of matrix elements. If not provided, the default implementation will\n   return java.lang.Object, and the matrix object is assumed to accept any type of value.\n   If a matrix is primitive-backed, it should return the appropriate primitive type e.g. Double/TYPE.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {element-type [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PTypeInfo, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :column 1, :line 149, :protocol-info {:methods {element-type [[m]]}}, :info nil, :end-line 149, :impls #{}, :doc "Protocol for querying the type of matrix elements. If not provided, the default implementation will\n   return java.lang.Object, and the matrix object is assumed to accept any type of value.\n   If a matrix is primitive-backed, it should return the appropriate primitive type e.g. Double/TYPE.", :jsdoc ("@interface")}, signum! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 918, :column 4, :end-line 918, :end-column 11, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/signum!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 918, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, scale-add {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 635, :column 4, :end-line 635, :end-column 13, :protocol clojure.core.matrix.protocols/PScaleAdd2, :doc "Scales array m1 by factor b, then adds array m2 scaled by factor b, then adds the constant", :arglists (quote ([m1 a m2 b constant]))}, :protocol clojure.core.matrix.protocols/PScaleAdd2, :name clojure.core.matrix.protocols/scale-add, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m1 a m2 b constant]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 633, :end-line 635, :max-fixed-arity 5, :fn-var true, :arglists (quote ([m1 a m2 b constant])), :doc "Scales array m1 by factor b, then adds array m2 scaled by factor b, then adds the constant"}, matrix-equals {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 495, :column 4, :end-line 495, :end-column 17, :protocol clojure.core.matrix.protocols/PMatrixEquality, :doc "Return true if a equals b, i.e. if a and b have the same shape and all elements are equal.\n     Must use numerical value comparison on numbers (==) to account for matrices that may hold a mix of\n     numercial types (e.g. java.lang.Long and java.lang.Double). Implementations that only support doubles\n     should use Number.doubleValue() to get a numeric value to compare.\n     May throw an exception if the matrices are non-numeric", :arglists (quote ([a b]))}, :protocol clojure.core.matrix.protocols/PMatrixEquality, :name clojure.core.matrix.protocols/matrix-equals, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 493, :end-line 495, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :doc "Return true if a equals b, i.e. if a and b have the same shape and all elements are equal.\n     Must use numerical value comparison on numbers (==) to account for matrices that may hold a mix of\n     numercial types (e.g. java.lang.Long and java.lang.Double). Implementations that only support doubles\n     should use Number.doubleValue() to get a numeric value to compare.\n     May throw an exception if the matrices are non-numeric"}, PSliceView2 {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 365, :column 14, :end-line 365, :end-column 25, :doc "Protocol for quick view access into a slices of an array. If implemented, must return\n   either a view or an immutable sub-matrix: it must *not* return copied data.\n\n   If the matrix is mutable, it must return a mutable view.\n\n   The default implementation creates a wrapper view.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {get-slice-view [[m dim i]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSliceView2, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :column 1, :line 365, :protocol-info {:methods {get-slice-view [[m dim i]]}}, :info nil, :end-line 365, :impls #{}, :doc "Protocol for quick view access into a slices of an array. If implemented, must return\n   either a view or an immutable sub-matrix: it must *not* return copied data.\n\n   If the matrix is mutable, it must return a mutable view.\n\n   The default implementation creates a wrapper view.", :jsdoc ("@interface")}, positive-definite? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1048, :column 4, :end-line 1048, :end-column 22, :protocol clojure.core.matrix.protocols/PMatrixTypes, :doc "Returns true if the matrix is positive definite", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixTypes, :name clojure.core.matrix.protocols/positive-definite?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 22, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1044, :end-line 1048, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns true if the matrix is positive definite"}, add-product {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 530, :column 4, :end-line 530, :end-column 15, :protocol clojure.core.matrix.protocols/PAddProduct, :doc nil, :arglists (quote ([m a b]))}, :protocol clojure.core.matrix.protocols/PAddProduct, :name clojure.core.matrix.protocols/add-product, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 526, :end-line 530, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m a b])), :doc nil}, round {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 893, :column 4, :end-line 893, :end-column 9, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/round, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 893, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, vector-transform! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 596, :column 4, :end-line 596, :end-column 21, :protocol clojure.core.matrix.protocols/PVectorTransform, :doc "Transforms a vector in place - mutates the vector argument", :arglists (quote ([t v]))}, :protocol clojure.core.matrix.protocols/PVectorTransform, :name clojure.core.matrix.protocols/vector-transform!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 21, :method-params ([t v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 589, :end-line 596, :max-fixed-arity 2, :fn-var true, :arglists (quote ([t v])), :doc "Transforms a vector in place - mutates the vector argument"}, get-0d {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 233, :column 4, :end-line 233, :end-column 10, :protocol clojure.core.matrix.protocols/PZeroDimensionAccess, :doc "Gets the scalar value in an 0d array.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PZeroDimensionAccess, :name clojure.core.matrix.protocols/get-0d, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 227, :end-line 233, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Gets the scalar value in an 0d array."}, PQRDecomposition {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1138, :column 14, :end-line 1138, :end-column 30, :doc "Protocol for QR decomposition", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {qr [[m options]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PQRDecomposition, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 30, :column 1, :line 1138, :protocol-info {:methods {qr [[m options]]}}, :info nil, :end-line 1138, :impls #{}, :doc "Protocol for QR decomposition", :jsdoc ("@interface")}, dense-coerce {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 211, :column 4, :end-line 211, :end-column 16, :protocol clojure.core.matrix.protocols/PDense, :doc "Attempts to coerce data to a dense array of implementation m. May return nil if not supported", :arglists (quote ([m data]))}, :protocol clojure.core.matrix.protocols/PDense, :name clojure.core.matrix.protocols/dense-coerce, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :method-params ([m data]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 209, :end-line 211, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m data])), :doc "Attempts to coerce data to a dense array of implementation m. May return nil if not supported"}, PTranspose {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 684, :column 14, :end-line 684, :end-column 24, :doc "Protocol for array transpose operation", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {transpose [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PTranspose, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 684, :protocol-info {:methods {transpose [[m]]}}, :info nil, :end-line 684, :impls #{}, :doc "Protocol for array transpose operation", :jsdoc ("@interface")}, normalise {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 757, :column 4, :end-line 757, :end-column 13, :protocol clojure.core.matrix.protocols/PVectorOps, :doc "Returns a new vector, normalised to length 1.0", :arglists (quote ([a]))}, :protocol clojure.core.matrix.protocols/PVectorOps, :name clojure.core.matrix.protocols/normalise, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 742, :end-line 757, :max-fixed-arity 1, :fn-var true, :arglists (quote ([a])), :doc "Returns a new vector, normalised to length 1.0"}, meta-info {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 45, :column 4, :end-line 45, :end-column 13, :protocol clojure.core.matrix.protocols/PImplementation, :doc "Returns optional meta-information on the implementation.\n\n     Standard keys:\n       :doc - containing a string describing an implementation", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PImplementation, :name clojure.core.matrix.protocols/meta-info, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 36, :end-line 45, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns optional meta-information on the implementation.\n\n     Standard keys:\n       :doc - containing a string describing an implementation"}, acos! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 906, :column 4, :end-line 906, :end-column 9, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/acos!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 906, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, assign! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 443, :column 4, :end-line 443, :end-column 11, :protocol clojure.core.matrix.protocols/PAssignment, :doc "Sets all the values in an array from a given source. Source may be a scalar\n     or any smaller array that can be broadcast to the shape of m.", :arglists (quote ([m source]))}, :protocol clojure.core.matrix.protocols/PAssignment, :name clojure.core.matrix.protocols/assign!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m source]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 441, :end-line 443, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m source])), :doc "Sets all the values in an array from a given source. Source may be a scalar\n     or any smaller array that can be broadcast to the shape of m."}, generic-mul {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1068, :column 4, :end-line 1068, :end-column 15, :protocol clojure.core.matrix.protocols/PGenericOperations, :doc "Generic 'mul' function for numerical values. Must satisfy (equals x (mul one x)).", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PGenericOperations, :name clojure.core.matrix.protocols/generic-mul, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1065, :end-line 1068, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Generic 'mul' function for numerical values. Must satisfy (equals x (mul one x))."}, element-min {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 935, :column 4, :end-line 935, :end-column 15, :protocol clojure.core.matrix.protocols/PElementMinMax, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PElementMinMax, :name clojure.core.matrix.protocols/element-min, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 932, :end-line 935, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PScaleAdd2 {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 633, :column 14, :end-line 633, :end-column 24, :doc "Protocol to support the immutable scale-add! operation.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {scale-add [[m1 a m2 b constant]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PScaleAdd2, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 633, :protocol-info {:methods {scale-add [[m1 a m2 b constant]]}}, :info nil, :end-line 633, :impls #{}, :doc "Protocol to support the immutable scale-add! operation.", :jsdoc ("@interface")}, get-row {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 339, :column 4, :end-line 339, :end-column 11, :protocol clojure.core.matrix.protocols/PMatrixSlices, :doc "Gets a row of a matrix with the given row index.", :arglists (quote ([m i]))}, :protocol clojure.core.matrix.protocols/PMatrixSlices, :name clojure.core.matrix.protocols/get-row, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 336, :end-line 339, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m i])), :doc "Gets a row of a matrix with the given row index."}, sinh! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 920, :column 4, :end-line 920, :end-column 9, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/sinh!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 920, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, native {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 206, :column 4, :end-line 206, :end-column 10, :protocol clojure.core.matrix.protocols/PNative, :doc "Attempts to coerce data to a native array of implementation m. May return nil if not supported", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PNative, :name clojure.core.matrix.protocols/native, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 203, :end-line 206, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Attempts to coerce data to a native array of implementation m. May return nil if not supported"}, logistic! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 830, :column 4, :end-line 830, :end-column 13, :protocol clojure.core.matrix.protocols/PLogisticMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PLogisticMutable, :name clojure.core.matrix.protocols/logistic!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 828, :end-line 830, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PSoftmaxMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 852, :column 14, :end-line 852, :end-column 29, :doc "Protocol to support mutable element-wise softmax function on a numerical vector.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {softmax! [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSoftmaxMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :column 1, :line 852, :protocol-info {:methods {softmax! [[m]]}}, :info nil, :end-line 852, :impls #{}, :doc "Protocol to support mutable element-wise softmax function on a numerical vector.", :jsdoc ("@interface")}, PElementMinMax {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 932, :column 14, :end-line 932, :end-column 28, :doc "Protocol to return the minimum and maximum elements in a numerical array. Must throw an exception\n   if the array is not numerical.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {element-min [[m]], element-max [[m]], element-clamp [[m a b]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PElementMinMax, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 932, :protocol-info {:methods {element-min [[m]], element-max [[m]], element-clamp [[m a b]]}}, :info nil, :end-line 932, :impls #{}, :doc "Protocol to return the minimum and maximum elements in a numerical array. Must throw an exception\n   if the array is not numerical.", :jsdoc ("@interface")}, index-from-ints {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1113, :column 4, :end-line 1113, :end-column 19, :protocol clojure.core.matrix.protocols/PIndexImplementation, :doc nil, :arglists (quote ([m xs]))}, :protocol clojure.core.matrix.protocols/PIndexImplementation, :name clojure.core.matrix.protocols/index-from-ints, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([m xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1107, :end-line 1113, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m xs])), :doc nil}, PAddScaledProductMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 546, :column 14, :end-line 546, :end-column 38, :doc "Protocol for mutable add-product! operation.\n\n   Intended to support optimised implementations for m = m + a * b * factor", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {add-scaled-product! [[m a b factor]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PAddScaledProductMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 38, :column 1, :line 546, :protocol-info {:methods {add-scaled-product! [[m a b factor]]}}, :info nil, :end-line 546, :impls #{}, :doc "Protocol for mutable add-product! operation.\n\n   Intended to support optimised implementations for m = m + a * b * factor", :jsdoc ("@interface")}, set-2d {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 103, :column 4, :end-line 103, :end-column 10, :protocol clojure.core.matrix.protocols/PIndexedSetting, :doc nil, :arglists (quote ([m row column v]))}, :protocol clojure.core.matrix.protocols/PIndexedSetting, :name clojure.core.matrix.protocols/set-2d, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m row column v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 103, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m row column v])), :doc nil}, assign {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 454, :column 4, :end-line 454, :end-column 10, :protocol clojure.core.matrix.protocols/PImmutableAssignment, :doc "Sets all the values in an array from a given source. Source may be a scalar\n     or a smaller array that can be broadcast to the shape of m.", :arglists (quote ([m source]))}, :protocol clojure.core.matrix.protocols/PImmutableAssignment, :name clojure.core.matrix.protocols/assign, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m source]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 452, :end-line 454, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m source])), :doc "Sets all the values in an array from a given source. Source may be a scalar\n     or a smaller array that can be broadcast to the shape of m."}, element-map! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 997, :column 4, :end-line 997, :end-column 16, :protocol clojure.core.matrix.protocols/PFunctionalOperations, :doc "Maps f over all elements of m (and optionally other matrices), mutating the elements of m in place.\n     Must throw an exception if m is not mutable.\n     f is expected to produce elements of a type supported by the implementation of m - failure\n     to do so may cause an error.", :arglists (quote ([m f] [m f a] [m f a more])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m f] [m f a] [m f a more]), :arglists ([m f] [m f a] [m f a more]), :arglists-meta (nil nil nil)}}, :protocol clojure.core.matrix.protocols/PFunctionalOperations, :name clojure.core.matrix.protocols/element-map!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([m f] [m f a] [m f a more]), :arglists ([m f] [m f a] [m f a more]), :arglists-meta (nil nil nil)}, :method-params ([m f] [m f a] [m f a more]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 983, :end-line 997, :max-fixed-arity 4, :fn-var true, :arglists ([m f] [m f a] [m f a more]), :doc "Maps f over all elements of m (and optionally other matrices), mutating the elements of m in place.\n     Must throw an exception if m is not mutable.\n     f is expected to produce elements of a type supported by the implementation of m - failure\n     to do so may cause an error."}, tanh! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 923, :column 4, :end-line 923, :end-column 9, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/tanh!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 923, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PLogisticMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 828, :column 14, :end-line 828, :end-column 30, :doc "Protocol to support mutable element-wise logistic function on a numerical array.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {logistic! [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PLogisticMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 30, :column 1, :line 828, :protocol-info {:methods {logistic! [[m]]}}, :info nil, :end-line 828, :impls #{}, :doc "Protocol to support mutable element-wise logistic function on a numerical array.", :jsdoc ("@interface")}, element-compare {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 943, :column 4, :end-line 943, :end-column 19, :protocol clojure.core.matrix.protocols/PCompare, :doc "Return the sign (signum) of the element-wise substraction of two scalars,\n    arrays or matrices i.e., must satisfy (signum (sub A B).", :arglists (quote ([a b]))}, :protocol clojure.core.matrix.protocols/PCompare, :name clojure.core.matrix.protocols/element-compare, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 941, :end-line 943, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :doc "Return the sign (signum) of the element-wise substraction of two scalars,\n    arrays or matrices i.e., must satisfy (signum (sub A B)."}, main-diagonal {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 418, :column 4, :end-line 418, :end-column 17, :protocol clojure.core.matrix.protocols/PMatrixSubComponents, :doc "Returns the main (leading) diagonal of a matrix.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixSubComponents, :name clojure.core.matrix.protocols/main-diagonal, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 415, :end-line 418, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the main (leading) diagonal of a matrix."}, PImplementation {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 36, :column 14, :end-line 36, :end-column 29, :doc "Protocol for general implementation functionality. Required to support implementation metadata and\n   matrix construction.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {implementation-key [[m]], meta-info [[m]], construct-matrix [[m data]], new-vector [[m length]], new-matrix [[m rows columns]], new-matrix-nd [[m shape]], supports-dimensionality? [[m dimensions]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PImplementation, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :column 1, :line 36, :protocol-info {:methods {implementation-key [[m]], meta-info [[m]], construct-matrix [[m data]], new-vector [[m length]], new-matrix [[m rows columns]], new-matrix-nd [[m shape]], supports-dimensionality? [[m dimensions]]}}, :info nil, :end-line 36, :impls #{}, :doc "Protocol for general implementation functionality. Required to support implementation metadata and\n   matrix construction.", :jsdoc ("@interface")}, PZeroDimensionConstruction {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 221, :column 14, :end-line 221, :end-column 40, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {new-scalar-array [[m] [m value]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PZeroDimensionConstruction, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 40, :column 1, :line 221, :protocol-info {:methods {new-scalar-array [[m] [m value]]}}, :info nil, :end-line 221, :impls #{}, :doc nil, :jsdoc ("@interface")}, PTransposeInPlace {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 715, :column 14, :end-line 715, :end-column 31, :doc "Protocol for mutable 2D matrix transpose in place", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {transpose! [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PTransposeInPlace, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 31, :column 1, :line 715, :protocol-info {:methods {transpose! [[m]]}}, :info nil, :end-line 715, :impls #{}, :doc "Protocol for mutable 2D matrix transpose in place", :jsdoc ("@interface")}, PMutableFill {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 459, :column 14, :end-line 459, :end-column 26, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {fill! [[m value]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMutableFill, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 26, :column 1, :line 459, :protocol-info {:methods {fill! [[m value]]}}, :info nil, :end-line 459, :impls #{}, :doc nil, :jsdoc ("@interface")}, get-nd {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 96, :column 4, :end-line 96, :end-column 10, :protocol clojure.core.matrix.protocols/PIndexedAccess, :doc nil, :arglists (quote ([m indexes]))}, :protocol clojure.core.matrix.protocols/PIndexedAccess, :name clojure.core.matrix.protocols/get-nd, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m indexes]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 91, :end-line 96, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m indexes])), :doc nil}, construct-matrix {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 50, :column 4, :end-line 50, :end-column 20, :protocol clojure.core.matrix.protocols/PImplementation, :doc "Returns a new n-dimensional array containing the given data. data should be in the form of either\n     nested sequences or a valid existing array.\n\n     The return value should be in the preferred format of the given implementation. If the implementation\n     does not support the required dimensionality or element type then it may either:\n      - Throw an error\n      - Return nil to indicate that a default implementation should be used instead\n\n     0-dimensional arrays / scalars are permitted.", :arglists (quote ([m data]))}, :protocol clojure.core.matrix.protocols/PImplementation, :name clojure.core.matrix.protocols/construct-matrix, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :method-params ([m data]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 36, :end-line 50, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m data])), :doc "Returns a new n-dimensional array containing the given data. data should be in the form of either\n     nested sequences or a valid existing array.\n\n     The return value should be in the preferred format of the given implementation. If the implementation\n     does not support the required dimensionality or element type then it may either:\n      - Throw an error\n      - Return nil to indicate that a default implementation should be used instead\n\n     0-dimensional arrays / scalars are permitted."}, abs {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 881, :column 4, :end-line 881, :end-column 7, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/abs, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 7, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 881, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, new-sparse-array {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 430, :column 4, :end-line 430, :end-column 20, :protocol clojure.core.matrix.protocols/PNewSparseArray, :doc "Creates a new sparse array with the given shape.", :arglists (quote ([m shape]))}, :protocol clojure.core.matrix.protocols/PNewSparseArray, :name clojure.core.matrix.protocols/new-sparse-array, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :method-params ([m shape]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 428, :end-line 430, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m shape])), :doc "Creates a new sparse array with the given shape."}, PAddProduct {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 526, :column 14, :end-line 526, :end-column 25, :doc "Optional protocol for add-product operation.\n\n   Intended to support optimised implementations for result = m + a * b", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {add-product [[m a b]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PAddProduct, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 25, :column 1, :line 526, :protocol-info {:methods {add-product [[m a b]]}}, :info nil, :end-line 526, :impls #{}, :doc "Optional protocol for add-product operation.\n\n   Intended to support optimised implementations for result = m + a * b", :jsdoc ("@interface")}, sinh {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 896, :column 4, :end-line 896, :end-column 8, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/sinh, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 896, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, element-divide! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 580, :column 4, :end-line 580, :end-column 19, :protocol clojure.core.matrix.protocols/PMatrixDivideMutable, :doc nil, :arglists (quote ([m] [m a])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([m] [m a]), :arglists ([m] [m a]), :arglists-meta (nil nil)}}, :protocol clojure.core.matrix.protocols/PMatrixDivideMutable, :name clojure.core.matrix.protocols/element-divide!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([m] [m a]), :arglists ([m] [m a]), :arglists-meta (nil nil)}, :method-params ([m] [m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 576, :end-line 580, :max-fixed-arity 2, :fn-var true, :arglists ([m] [m a]), :doc nil}, as-object-array {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 481, :column 4, :end-line 481, :end-column 19, :protocol clojure.core.matrix.protocols/PObjectArrayOutput, :doc "Returns the internal object array used by m. If no such array is used, returns nil.\n     Provides an opportunity to avoid copying the internal array.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PObjectArrayOutput, :name clojure.core.matrix.protocols/as-object-array, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 475, :end-line 481, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the internal object array used by m. If no such array is used, returns nil.\n     Provides an opportunity to avoid copying the internal array."}, PMathsFunctionsMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 903, :column 14, :end-line 903, :end-column 36, :doc "Protocol to support mutable mathematical functions applied element-wise to a numerical array.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {sqrt! [[m]], asin! [[m]], cos! [[m]], ceil! [[m]], atan! [[m]], to-radians! [[m]], abs! [[m]], log! [[m]], cosh! [[m]], sin! [[m]], tan! [[m]], exp! [[m]], to-degrees! [[m]], cbrt! [[m]], round! [[m]], signum! [[m]], acos! [[m]], sinh! [[m]], tanh! [[m]], floor! [[m]], log10! [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMathsFunctionsMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 36, :column 1, :line 903, :protocol-info {:methods {sqrt! [[m]], asin! [[m]], cos! [[m]], ceil! [[m]], atan! [[m]], to-radians! [[m]], abs! [[m]], log! [[m]], cosh! [[m]], sin! [[m]], tan! [[m]], exp! [[m]], to-degrees! [[m]], cbrt! [[m]], round! [[m]], signum! [[m]], acos! [[m]], sinh! [[m]], tanh! [[m]], floor! [[m]], log10! [[m]]}}, :info nil, :end-line 903, :impls #{}, :doc "Protocol to support mutable mathematical functions applied element-wise to a numerical array.", :jsdoc ("@interface")}, get-major-slice-view {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 363, :column 4, :end-line 363, :end-column 24, :protocol clojure.core.matrix.protocols/PSliceView, :doc "Gets a view of a major array slice", :arglists (quote ([m i]))}, :protocol clojure.core.matrix.protocols/PSliceView, :name clojure.core.matrix.protocols/get-major-slice-view, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :method-params ([m i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 356, :end-line 363, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m i])), :doc "Gets a view of a major array slice"}, label {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1121, :column 4, :end-line 1121, :end-column 9, :protocol clojure.core.matrix.protocols/PDimensionLabels, :doc "Returns the label at a specific index along the given dimension", :arglists (quote ([m dim i]))}, :protocol clojure.core.matrix.protocols/PDimensionLabels, :name clojure.core.matrix.protocols/label, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m dim i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1119, :end-line 1121, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m dim i])), :doc "Returns the label at a specific index along the given dimension"}, broadcast-coerce {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 303, :column 4, :end-line 303, :end-column 20, :protocol clojure.core.matrix.protocols/PBroadcastCoerce, :doc "Broadcasts and coerces a to the same shape and implementation as m", :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PBroadcastCoerce, :name clojure.core.matrix.protocols/broadcast-coerce, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 299, :end-line 303, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc "Broadcasts and coerces a to the same shape and implementation as m"}, same-shape? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 334, :column 4, :end-line 334, :end-column 15, :protocol clojure.core.matrix.protocols/PSameShape, :doc nil, :arglists (quote ([a b]))}, :protocol clojure.core.matrix.protocols/PSameShape, :name clojure.core.matrix.protocols/same-shape?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 330, :end-line 334, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :doc nil}, clone {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 124, :column 4, :end-line 124, :end-column 9, :protocol clojure.core.matrix.protocols/PMatrixCloning, :doc "Returns a clone of an array. Must be a new independent (non-view)\n              instance if the array is mutable.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMatrixCloning, :name clojure.core.matrix.protocols/clone, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 121, :end-line 124, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns a clone of an array. Must be a new independent (non-view)\n              instance if the array is mutable."}, to-object-array {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 477, :column 4, :end-line 477, :end-column 19, :protocol clojure.core.matrix.protocols/PObjectArrayOutput, :doc "Returns an object array containing the values of m in row-major order. May or may not be\n     the internal object array used by m, depending on the implementation.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PObjectArrayOutput, :name clojure.core.matrix.protocols/to-object-array, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 475, :end-line 477, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns an object array containing the values of m in row-major order. May or may not be\n     the internal object array used by m, depending on the implementation."}, PMutableCoercion {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 183, :column 14, :end-line 183, :end-column 30, :doc "Protocol for coercing to a mutable format. May return the original array, if it is already fully mutable,\n   otherwise should return a fully mutable copy of the array.\n\n   Should return nil to indicate that this implementation cannot create a mutable array from the given data.\n\n   The default implementation will attempt to choose a suitable mutable matrix implementation.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {ensure-mutable [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMutableCoercion, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 30, :column 1, :line 183, :protocol-info {:methods {ensure-mutable [[m]]}}, :info nil, :end-line 183, :impls #{}, :doc "Protocol for coercing to a mutable format. May return the original array, if it is already fully mutable,\n   otherwise should return a fully mutable copy of the array.\n\n   Should return nil to indicate that this implementation cannot create a mutable array from the given data.\n\n   The default implementation will attempt to choose a suitable mutable matrix implementation.", :jsdoc ("@interface")}, coerce-param {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 277, :column 4, :end-line 277, :end-column 16, :protocol clojure.core.matrix.protocols/PCoercion, :doc "Attempts to coerce param into a matrix format supported by the implementation of matrix m.\n     May return nil if unable to do so, in which case a default implementation can be used.", :arglists (quote ([m param]))}, :protocol clojure.core.matrix.protocols/PCoercion, :name clojure.core.matrix.protocols/coerce-param, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :method-params ([m param]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 261, :end-line 277, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m param])), :doc "Attempts to coerce param into a matrix format supported by the implementation of matrix m.\n     May return nil if unable to do so, in which case a default implementation can be used."}, set-nd! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 119, :column 4, :end-line 119, :end-column 11, :protocol clojure.core.matrix.protocols/PIndexedSettingMutable, :doc nil, :arglists (quote ([m indexes v]))}, :protocol clojure.core.matrix.protocols/PIndexedSettingMutable, :name clojure.core.matrix.protocols/set-nd!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m indexes v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 114, :end-line 119, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m indexes v])), :doc nil}, join-columns {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1182, :column 4, :end-line 1182, :end-column 16, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :doc "Returns a dataset created by combining the columns of the given datasets", :arglists (quote ([ds1 ds2]))}, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :name clojure.core.matrix.protocols/join-columns, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :method-params ([ds1 ds2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1170, :end-line 1182, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ds1 ds2])), :doc "Returns a dataset created by combining the columns of the given datasets"}, generic-value {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1063, :column 4, :end-line 1063, :end-column 17, :protocol clojure.core.matrix.protocols/PGenericValues, :doc "Generic value for a new array. Likely to be zero or nil.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PGenericValues, :name clojure.core.matrix.protocols/generic-value, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1059, :end-line 1063, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Generic value for a new array. Likely to be zero or nil."}, permutation-matrix {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 255, :column 4, :end-line 255, :end-column 22, :protocol clojure.core.matrix.protocols/PPermutationMatrix, :doc nil, :arglists (quote ([m permutation]))}, :protocol clojure.core.matrix.protocols/PPermutationMatrix, :name clojure.core.matrix.protocols/permutation-matrix, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 22, :method-params ([m permutation]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 253, :end-line 255, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m permutation])), :doc nil}, floor! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 914, :column 4, :end-line 914, :end-column 10, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/floor!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 914, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, is-vector? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 83, :column 4, :end-line 83, :end-column 14, :protocol clojure.core.matrix.protocols/PDimensionInfo, :doc "Tests whether an object is a vector (1D array)", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PDimensionInfo, :name clojure.core.matrix.protocols/is-vector?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 71, :end-line 83, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Tests whether an object is a vector (1D array)"}, PVectorDistance {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 766, :column 14, :end-line 766, :end-column 29, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {distance [[a b]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PVectorDistance, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :column 1, :line 766, :protocol-info {:methods {distance [[a b]]}}, :info nil, :end-line 766, :impls #{}, :doc nil, :jsdoc ("@interface")}, PMatrixColumns {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 352, :column 14, :end-line 352, :end-column 28, :doc "Protocol for accessing columns of a matrix", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {get-columns [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixColumns, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 352, :protocol-info {:methods {get-columns [[m]]}}, :info nil, :end-line 352, :impls #{}, :doc "Protocol for accessing columns of a matrix", :jsdoc ("@interface")}, ensure-type {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1272, :column 7, :end-line 1272, :end-column 18, :arglists (quote ([m klass])), :doc "Checks if an array can contain a specified Java type, if so returns the original array, otherwise\n   returns a copy of the array that can support the specified type."}, :name clojure.core.matrix.protocols/ensure-type, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([m klass]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1272, :end-line 1272, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m klass])), :doc "Checks if an array can contain a specified Java type, if so returns the original array, otherwise\n   returns a copy of the array that can support the specified type."}, square {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 822, :column 4, :end-line 822, :end-column 10, :protocol clojure.core.matrix.protocols/PSquare, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PSquare, :name clojure.core.matrix.protocols/square, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 820, :end-line 822, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, set-nd {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 104, :column 4, :end-line 104, :end-column 10, :protocol clojure.core.matrix.protocols/PIndexedSetting, :doc nil, :arglists (quote ([m indexes v]))}, :protocol clojure.core.matrix.protocols/PIndexedSetting, :name clojure.core.matrix.protocols/set-nd, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m indexes v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 104, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m indexes v])), :doc nil}, compute-matrix {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 682, :column 4, :end-line 682, :end-column 18, :protocol clojure.core.matrix.protocols/PComputeMatrix, :doc nil, :arglists (quote ([m shape f]))}, :protocol clojure.core.matrix.protocols/PComputeMatrix, :name clojure.core.matrix.protocols/compute-matrix, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([m shape f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 679, :end-line 682, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m shape f])), :doc nil}, length {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 753, :column 4, :end-line 753, :end-column 10, :protocol clojure.core.matrix.protocols/PVectorOps, :doc "Euclidian length of a vector.", :arglists (quote ([a]))}, :protocol clojure.core.matrix.protocols/PVectorOps, :name clojure.core.matrix.protocols/length, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 742, :end-line 753, :max-fixed-arity 1, :fn-var true, :arglists (quote ([a])), :doc "Euclidian length of a vector."}, PSliceViewSeq {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 392, :column 14, :end-line 392, :end-column 27, :doc "Returns the row-major slice views of the array.\n\n   These must be arrays if the array is mutable, i.e. slices of a 1D vector\n   must be 0-dimensional mutable arrays.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {get-major-slice-view-seq [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSliceViewSeq, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 27, :column 1, :line 392, :protocol-info {:methods {get-major-slice-view-seq [[m]]}}, :info nil, :end-line 392, :impls #{}, :doc "Returns the row-major slice views of the array.\n\n   These must be arrays if the array is mutable, i.e. slices of a 1D vector\n   must be 0-dimensional mutable arrays.", :jsdoc ("@interface")}, element-reduce {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1005, :column 4, :end-line 1005, :end-column 18, :protocol clojure.core.matrix.protocols/PFunctionalOperations, :doc "Reduces with the function f over all elements of m.", :arglists (quote ([m f] [m f init])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([m f] [m f init]), :arglists ([m f] [m f init]), :arglists-meta (nil nil)}}, :protocol clojure.core.matrix.protocols/PFunctionalOperations, :name clojure.core.matrix.protocols/element-reduce, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([m f] [m f init]), :arglists ([m f] [m f init]), :arglists-meta (nil nil)}, :method-params ([m f] [m f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 983, :end-line 1005, :max-fixed-arity 3, :fn-var true, :arglists ([m f] [m f init]), :doc "Reduces with the function f over all elements of m."}, supports-type? {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1266, :column 7, :end-line 1266, :end-column 21, :arglists (quote ([m klass])), :doc "Checks if an array can contain a specified Java type."}, :name clojure.core.matrix.protocols/supports-type?, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 21, :method-params ([m klass]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1266, :end-line 1266, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m klass])), :doc "Checks if an array can contain a specified Java type."}, sin {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 895, :column 4, :end-line 895, :end-column 7, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/sin, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 7, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 895, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, element-lt {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 956, :column 4, :end-line 956, :end-column 14, :protocol clojure.core.matrix.protocols/PCompare, :doc "Return a binary array or matrix where elements of m less-than a are\n    represented by 1 and elements greater-than a are represented as 0.", :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PCompare, :name clojure.core.matrix.protocols/element-lt, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 941, :end-line 956, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc "Return a binary array or matrix where elements of m less-than a are\n    represented by 1 and elements greater-than a are represented as 0."}, generic-add {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1067, :column 4, :end-line 1067, :end-column 15, :protocol clojure.core.matrix.protocols/PGenericOperations, :doc "Generic 'add' function for numerical values. Must satisfy (equals x (add zero x)).", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PGenericOperations, :name clojure.core.matrix.protocols/generic-add, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1065, :end-line 1067, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Generic 'add' function for numerical values. Must satisfy (equals x (add zero x))."}, relu {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 842, :column 4, :end-line 842, :end-column 8, :protocol clojure.core.matrix.protocols/PReLU, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PReLU, :name clojure.core.matrix.protocols/relu, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 8, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 840, :end-line 842, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, set-column {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 876, :column 4, :end-line 876, :end-column 14, :protocol clojure.core.matrix.protocols/PColumnSetting, :doc nil, :arglists (quote ([m i column]))}, :protocol clojure.core.matrix.protocols/PColumnSetting, :name clojure.core.matrix.protocols/set-column, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m i column]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 874, :end-line 876, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m i column])), :doc nil}, merge-datasets {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1178, :column 4, :end-line 1178, :end-column 18, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :doc "Returns a dataset created by combining columns of the given datasets. In case of columns with duplicate names, last-one-wins strategy is applied", :arglists (quote ([ds1 ds2]))}, :protocol clojure.core.matrix.protocols/PDatasetImplementation, :name clojure.core.matrix.protocols/merge-datasets, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([ds1 ds2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1170, :end-line 1178, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ds1 ds2])), :doc "Returns a dataset created by combining columns of the given datasets. In case of columns with duplicate names, last-one-wins strategy is applied"}, PSliceSeq {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 374, :column 14, :end-line 374, :end-column 23, :doc "Returns the row-major slices of the array as a sequence.\n\n   These must be views or immutable sub-arrays for higher order slices, or scalars\n   for the slices of a 1D vector.\n\n   The default implementation uses get-major-slice-view to obtain the slices.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {get-major-slice-seq [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSliceSeq, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :column 1, :line 374, :protocol-info {:methods {get-major-slice-seq [[m]]}}, :info nil, :end-line 374, :impls #{}, :doc "Returns the row-major slices of the array as a sequence.\n\n   These must be views or immutable sub-arrays for higher order slices, or scalars\n   for the slices of a 1D vector.\n\n   The default implementation uses get-major-slice-view to obtain the slices.", :jsdoc ("@interface")}, shift-all {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 710, :column 4, :end-line 710, :end-column 13, :protocol clojure.core.matrix.protocols/PShift, :doc "Shift along all specified dimensions as a single operation.\n\n     `shifts` may be any sequence of integer shift amounts.", :arglists (quote ([m shifts]))}, :protocol clojure.core.matrix.protocols/PShift, :name clojure.core.matrix.protocols/shift-all, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 13, :method-params ([m shifts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 705, :end-line 710, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m shifts])), :doc "Shift along all specified dimensions as a single operation.\n\n     `shifts` may be any sequence of integer shift amounts."}, PMatrixEquality {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 493, :column 14, :end-line 493, :end-column 29, :doc "Protocol for numerical array equality operations.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {matrix-equals [[a b]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixEquality, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 29, :column 1, :line 493, :protocol-info {:methods {matrix-equals [[a b]]}}, :info nil, :end-line 493, :impls #{}, :doc "Protocol for numerical array equality operations.", :jsdoc ("@interface")}, reshape {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 317, :column 4, :end-line 317, :end-column 11, :protocol clojure.core.matrix.protocols/PReshaping, :doc nil, :arglists (quote ([m shape]))}, :protocol clojure.core.matrix.protocols/PReshaping, :name clojure.core.matrix.protocols/reshape, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 11, :method-params ([m shape]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 311, :end-line 317, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m shape])), :doc nil}, PZeroCount {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 434, :column 14, :end-line 434, :end-column 24, :doc "Protocol for counting the number of zeros in a numerical array. Must return an integer value\n   representing the precise number of zeros.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {zero-count [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PZeroCount, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 434, :protocol-info {:methods {zero-count [[m]]}}, :info nil, :end-line 434, :impls #{}, :doc "Protocol for counting the number of zeros in a numerical array. Must return an integer value\n   representing the precise number of zeros.", :jsdoc ("@interface")}, PMatrixDivide {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 568, :column 14, :end-line 568, :end-column 27, :doc "Protocol to support element-wise division operator.\n\n   One-arg version returns the reciprocal of all elements.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {element-divide [[m] [m a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixDivide, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 27, :column 1, :line 568, :protocol-info {:methods {element-divide [[m] [m a]]}}, :info nil, :end-line 568, :impls #{}, :doc "Protocol to support element-wise division operator.\n\n   One-arg version returns the reciprocal of all elements.", :jsdoc ("@interface")}, PLerp {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 638, :column 14, :end-line 638, :end-column 19, :doc "Protocol to support the lerp linear interpolation function.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {lerp [[a b factor]], lerp! [[a b factor]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PLerp, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :column 1, :line 638, :protocol-info {:methods {lerp [[a b factor]], lerp! [[a b factor]]}}, :info nil, :end-line 638, :impls #{}, :doc "Protocol to support the lerp linear interpolation function.", :jsdoc ("@interface")}, dimensionality {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 74, :column 4, :end-line 74, :end-column 18, :protocol clojure.core.matrix.protocols/PDimensionInfo, :doc "Returns the number of dimensions of an array, as an integer (greater than or equal to zero). ", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PDimensionInfo, :name clojure.core.matrix.protocols/dimensionality, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 18, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 71, :end-line 74, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the number of dimensions of an array, as an integer (greater than or equal to zero). "}, PNative {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 203, :column 14, :end-line 203, :end-column 21, :doc "Protocol for creating and handling native arrays. Implementations must return a native format array if they\n   are able to, or nil otherwise.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {native [[m]], native? [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PNative, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 21, :column 1, :line 203, :protocol-info {:methods {native [[m]], native? [[m]]}}, :info nil, :end-line 203, :impls #{}, :doc "Protocol for creating and handling native arrays. Implementations must return a native format array if they\n   are able to, or nil otherwise.", :jsdoc ("@interface")}, PBLASBase {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 975, :column 14, :end-line 975, :end-column 23, :doc "Base blas support.  Note that the largest differences\nfrom the C blas functions is that the return value is provided\nfirst so that the protocol machinery can work (as opposed to alpha, which\nwould often be a numeric base type).", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {gemm! [[c trans-a? trans-b? alpha a b beta]], gemv! [[c trans-a? alpha a b beta]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PBLASBase, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 23, :column 1, :line 975, :protocol-info {:methods {gemm! [[c trans-a? trans-b? alpha a b beta]], gemv! [[c trans-a? alpha a b beta]]}}, :info nil, :end-line 975, :impls #{}, :doc "Base blas support.  Note that the largest differences\nfrom the C blas functions is that the return value is provided\nfirst so that the protocol machinery can work (as opposed to alpha, which\nwould often be a numeric base type).", :jsdoc ("@interface")}, PMatrixSlices {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 336, :column 14, :end-line 336, :end-column 27, :doc "Protocol to support getting slices of an array.  If implemented, must return either a view, a scalar\n   or an immutable sub-matrix: it must *not* return copied data. i.e. making a full copy must be avoided.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {get-row [[m i]], get-column [[m i]], get-major-slice [[m i]], get-slice [[m dimension i]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PMatrixSlices, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 27, :column 1, :line 336, :protocol-info {:methods {get-row [[m i]], get-column [[m i]], get-major-slice [[m i]], get-slice [[m dimension i]]}}, :info nil, :end-line 336, :impls #{}, :doc "Protocol to support getting slices of an array.  If implemented, must return either a view, a scalar\n   or an immutable sub-matrix: it must *not* return copied data. i.e. making a full copy must be avoided.", :jsdoc ("@interface")}, PIndicesAccess {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1092, :column 14, :end-line 1092, :end-column 28, :doc "Protocol for getting elements of an array at the specified indices.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {get-indices [[a indices]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PIndicesAccess, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 28, :column 1, :line 1092, :protocol-info {:methods {get-indices [[a indices]]}}, :info nil, :end-line 1092, :impls #{}, :doc "Protocol for getting elements of an array at the specified indices.", :jsdoc ("@interface")}, PSetInnerProductMutable {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 663, :column 14, :end-line 663, :end-column 37, :doc "Protocol to support the mutable set-inner-product! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant factors e.g. 0.0 and 1.0 but this is not mandatory.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {set-inner-product! [[m a b] [m a b factor]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSetInnerProductMutable, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 37, :column 1, :line 663, :protocol-info {:methods {set-inner-product! [[m a b] [m a b factor]]}}, :info nil, :end-line 663, :impls #{}, :doc "Protocol to support the mutable set-inner-product! operation. This is a common operation that may be\n   optimised by the underlying implementation. Implementations should consider extra optimisations for\n   specific constant factors e.g. 0.0 and 1.0 but this is not mandatory.", :jsdoc ("@interface")}, rotate {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 697, :column 4, :end-line 697, :end-column 10, :protocol clojure.core.matrix.protocols/PRotate, :doc nil, :arglists (quote ([m dim places]))}, :protocol clojure.core.matrix.protocols/PRotate, :name clojure.core.matrix.protocols/rotate, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m dim places]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 693, :end-line 697, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m dim places])), :doc nil}, signum {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 894, :column 4, :end-line 894, :end-column 10, :protocol clojure.core.matrix.protocols/PMathsFunctions, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctions, :name clojure.core.matrix.protocols/signum, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 879, :end-line 894, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PReLU {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 840, :column 14, :end-line 840, :end-column 19, :doc "Protocol to support element-wise relu function on a numerical array.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {relu [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PReLU, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :column 1, :line 840, :protocol-info {:methods {relu [[m]]}}, :info nil, :end-line 840, :impls #{}, :doc "Protocol to support element-wise relu function on a numerical array.", :jsdoc ("@interface")}, column-names {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1129, :column 4, :end-line 1129, :end-column 16, :protocol clojure.core.matrix.protocols/PColumnNames, :doc "Returns all labels along the columns on an array", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PColumnNames, :name clojure.core.matrix.protocols/column-names, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1124, :end-line 1129, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns all labels along the columns on an array"}, element-ne {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 968, :column 4, :end-line 968, :end-column 14, :protocol clojure.core.matrix.protocols/PCompare, :doc "Return a binary array or matrix where elements of m not-equal to a are\n    represented by 1 and elements equal to a are represented as 0.", :arglists (quote ([m a]))}, :protocol clojure.core.matrix.protocols/PCompare, :name clojure.core.matrix.protocols/element-ne, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([m a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 941, :end-line 968, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m a])), :doc "Return a binary array or matrix where elements of m not-equal to a are\n    represented by 1 and elements equal to a are represented as 0."}, log10! {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 916, :column 4, :end-line 916, :end-column 10, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PMathsFunctionsMutable, :name clojure.core.matrix.protocols/log10!, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 10, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 903, :end-line 916, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, vector-dot {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 744, :column 4, :end-line 744, :end-column 14, :protocol clojure.core.matrix.protocols/PVectorOps, :doc "Numerical dot product of two vectors. Must return a scalar value if the two parameters are\n      vectors of equal length.\n\n      If the vectors are of unequal length, should throw an exception (however returning nil is\n      also acceptable).\n\n      Otherwise the implementation may optionally either return nil or compute a higher dimensional\n      inner-product (if it is able to do so).", :arglists (quote ([a b]))}, :protocol clojure.core.matrix.protocols/PVectorOps, :name clojure.core.matrix.protocols/vector-dot, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 14, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 742, :end-line 744, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :doc "Numerical dot product of two vectors. Must return a scalar value if the two parameters are\n      vectors of equal length.\n\n      If the vectors are of unequal length, should throw an exception (however returning nil is\n      also acceptable).\n\n      Otherwise the implementation may optionally either return nil or compute a higher dimensional\n      inner-product (if it is able to do so)."}, to-double-array {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 466, :column 4, :end-line 466, :end-column 19, :protocol clojure.core.matrix.protocols/PDoubleArrayOutput, :doc "Returns a double array containing the values of m in row-major order. May or may not be\n     the internal double array used by m, depending on the implementation.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PDoubleArrayOutput, :name clojure.core.matrix.protocols/to-double-array, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 19, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 464, :end-line 466, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns a double array containing the values of m in row-major order. May or may not be\n     the internal double array used by m, depending on the implementation."}, generic-div {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1070, :column 4, :end-line 1070, :end-column 15, :protocol clojure.core.matrix.protocols/PGenericOperations, :doc "Generic 'div' function for numerical values.", :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PGenericOperations, :name clojure.core.matrix.protocols/generic-div, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 15, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1065, :end-line 1070, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Generic 'div' function for numerical values."}, immutable-matrix {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 219, :column 4, :end-line 219, :end-column 20, :protocol clojure.core.matrix.protocols/PImmutableMatrixConstruction, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PImmutableMatrixConstruction, :name clojure.core.matrix.protocols/immutable-matrix, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 214, :end-line 219, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, element-type {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 153, :column 4, :end-line 153, :end-column 16, :protocol clojure.core.matrix.protocols/PTypeInfo, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PTypeInfo, :name clojure.core.matrix.protocols/element-type, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 16, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 149, :end-line 153, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, PSelect {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1075, :column 14, :end-line 1075, :end-column 21, :doc "Protocol for the sel function. See the docstring for clojure.core.matrix/select for\n   more information on possible argument values.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {select [[a args]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PSelect, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 21, :column 1, :line 1075, :protocol-info {:methods {select [[a args]]}}, :info nil, :end-line 1075, :impls #{}, :doc "Protocol for the sel function. See the docstring for clojure.core.matrix/select for\n   more information on possible argument values.", :jsdoc ("@interface")}, index-from-longs {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1112, :column 4, :end-line 1112, :end-column 20, :protocol clojure.core.matrix.protocols/PIndexImplementation, :doc nil, :arglists (quote ([m xs]))}, :protocol clojure.core.matrix.protocols/PIndexImplementation, :name clojure.core.matrix.protocols/index-from-longs, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 20, :method-params ([m xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1107, :end-line 1112, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m xs])), :doc nil}, PElementCount {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 927, :column 14, :end-line 927, :end-column 27, :doc "Protocol to return the total count of elements in matrix. Result may be any integer type,\n   typically a java.lang.Long", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {element-count [[m]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PElementCount, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 27, :column 1, :line 927, :protocol-info {:methods {element-count [[m]]}}, :info nil, :end-line 927, :impls #{}, :doc "Protocol to return the total count of elements in matrix. Result may be any integer type,\n   typically a java.lang.Long", :jsdoc ("@interface")}, PVectorOps {:meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 742, :column 14, :end-line 742, :end-column 24, :doc "Protocol to support common numerical vector operations.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {vector-dot [[a b]], length [[a]], length-squared [[a]], normalise [[a]]}}}, :protocol-symbol true, :name clojure.core.matrix.protocols/PVectorOps, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 24, :column 1, :line 742, :protocol-info {:methods {vector-dot [[a b]], length [[a]], length-squared [[a]], normalise [[a]]}}, :info nil, :end-line 742, :impls #{}, :doc "Protocol to support common numerical vector operations.", :jsdoc ("@interface")}, index-to-ints {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 1111, :column 4, :end-line 1111, :end-column 17, :protocol clojure.core.matrix.protocols/PIndexImplementation, :doc nil, :arglists (quote ([m]))}, :protocol clojure.core.matrix.protocols/PIndexImplementation, :name clojure.core.matrix.protocols/index-to-ints, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 17, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1107, :end-line 1111, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc nil}, order {:protocol-inline nil, :meta {:file "/home/pedro/GitHub/pong/resources/public/js/clojure/core/matrix/protocols.cljc", :line 732, :column 4, :end-line 732, :end-column 9, :protocol clojure.core.matrix.protocols/POrder, :doc nil, :arglists (quote ([m indices] [m dimension indices])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([m indices] [m dimension indices]), :arglists ([m indices] [m dimension indices]), :arglists-meta (nil nil)}}, :protocol clojure.core.matrix.protocols/POrder, :name clojure.core.matrix.protocols/order, :variadic false, :file "resources/public/js/clojure/core/matrix/protocols.cljc", :end-column 9, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([m indices] [m dimension indices]), :arglists ([m indices] [m dimension indices]), :arglists-meta (nil nil)}, :method-params ([m indices] [m dimension indices]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 720, :end-line 732, :max-fixed-arity 3, :fn-var true, :arglists ([m indices] [m dimension indices]), :doc nil}}, :require-macros {clojure.core.matrix.macros clojure.core.matrix.macros, mops clojure.core.matrix.impl.mathsops, clojure.core.matrix.impl.mathsops clojure.core.matrix.impl.mathsops}, :cljs.analyzer/constants {:seen #{:default}, :order [:default]}, :doc "Namespace for core.matrix protocols. These protocols are intended to be implemented by\n   core.matrix array implemntations.\n\n   End users should normally avoid using this namespace directly\n   and instead use the functions in the main clojure.core.matrix API"}