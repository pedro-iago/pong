;; Analyzed by ClojureScript 1.7.228
{:use-macros nil, :excludes #{range sorted-set split-at sorted-set-by sorted-map-by sorted-map}, :name clojure.data.avl, :imports nil, :requires nil, :uses nil, :defs {split-key {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 1167, :column 7, :end-line 1167, :end-column 16, :arglists (quote ([k coll])), :doc "(alpha)\n\n  Returns [left e? right], where left and right are collections of\n  the same type as coll and containing, respectively, the keys below\n  and above k in the ordering determined by coll's comparator, while\n  e? is the entry at key k for maps, the stored copy of the key k for\n  sets, nil if coll does not contain k."}, :name clojure.data.avl/split-key, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 16, :method-params ([k coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1167, :end-line 1167, :max-fixed-arity 2, :fn-var true, :arglists (quote ([k coll])), :doc "(alpha)\n\n  Returns [left e? right], where left and right are collections of\n  the same type as coll and containing, respectively, the keys below\n  and above k in the ordering determined by coll's comparator, while\n  e? is the entry at key k for maps, the stored copy of the key k for\n  sets, nil if coll does not contain k."}, AVLMap {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection clojure.data.avl/Object cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name clojure.data.avl/AVLMap, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 16, :type true, :column 10, :line 757, :record false, :end-line 757, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, maybe-rebalance {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 225, :column 17, :end-line 225, :end-column 32, :private true, :arglists (quote ([node]))}, :private true, :name clojure.data.avl/maybe-rebalance, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 32, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 225, :end-line 225, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, seq-push {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 664, :column 17, :end-line 664, :end-column 25, :private true, :arglists (quote ([node stack ascending?]))}, :private true, :name clojure.data.avl/seq-push, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 25, :method-params ([node stack ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 664, :end-line 664, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node stack ascending?]))}, ensure-editable {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 75, :column 17, :end-line 75, :end-column 32, :private true, :arglists (quote ([edit] [edit node])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([edit] [edit node]), :arglists ([edit] [edit node]), :arglists-meta (nil nil)}}, :private true, :name clojure.data.avl/ensure-editable, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 32, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([edit] [edit node]), :arglists ([edit] [edit node]), :arglists-meta (nil nil)}, :method-params ([edit] [edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 75, :end-line 75, :max-fixed-arity 2, :fn-var true, :arglists ([edit] [edit node])}, rotate-right! {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 155, :column 17, :end-line 155, :end-column 30, :private true, :arglists (quote ([edit node]))}, :private true, :name clojure.data.avl/rotate-right!, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 30, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 155, :end-line 155, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, rank-of {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 1153, :column 7, :end-line 1153, :end-column 14, :arglists (quote ([coll x])), :doc "Returns the rank of x in coll or -1 if not present."}, :name clojure.data.avl/rank-of, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 14, :method-params ([coll x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1153, :end-line 1153, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll x])), :doc "Returns the rank of x in coll or -1 if not present."}, AVLMapSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection clojure.data.avl/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name clojure.data.avl/AVLMapSeq, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 19, :type true, :column 10, :line 690, :record false, :end-line 690, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, join {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 522, :column 17, :end-line 522, :end-column 21, :private true, :arglists (quote ([comp left-count left right]))}, :private true, :name clojure.data.avl/join, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 21, :method-params ([comp left-count left right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 522, :end-line 522, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp left-count left right]))}, height {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 70, :column 17, :end-line 70, :end-column 23, :private true, :arglists (quote ([node]))}, :private true, :name clojure.data.avl/height, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 23, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 70, :end-line 70, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, range {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 651, :column 17, :end-line 651, :end-column 22, :private true, :arglists (quote ([comp node low high]))}, :private true, :name clojure.data.avl/range, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 22, :method-params ([comp node low high]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 651, :end-line 651, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp node low high]))}, rotate-left {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 89, :column 17, :end-line 89, :end-column 28, :private true, :arglists (quote ([node]))}, :private true, :name clojure.data.avl/rotate-left, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 28, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 89, :end-line 89, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, select {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 204, :column 17, :end-line 204, :end-column 23, :private true, :arglists (quote ([node rank]))}, :private true, :name clojure.data.avl/select, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 23, :method-params ([node rank]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 204, :end-line 204, :max-fixed-arity 2, :fn-var true, :arglists (quote ([node rank]))}, ->AVLTransientSet {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 1055, :column 10, :end-line 1055, :end-column 25, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :factory :positional, :arglists (quote ([transient-avl-map]))}, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name clojure.data.avl/->AVLTransientSet, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 25, :method-params ([transient-avl-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1055, :end-line 1055, :max-fixed-arity 1, :fn-var true, :arglists (quote ([transient-avl-map])), :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, rotate-left! {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 113, :column 17, :end-line 113, :end-column 29, :private true, :arglists (quote ([edit node]))}, :private true, :name clojure.data.avl/rotate-left!, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 29, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 113, :end-line 113, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, nearest {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 1158, :column 7, :end-line 1158, :end-column 14, :arglists (quote ([coll test x])), :doc "(alpha)\n\n  Equivalent to, but more efficient than, (first (subseq* coll test x)),\n  where subseq* is clojure.core/subseq for test in #{>, >=} and\n  clojure.core/rsubseq for test in #{<, <=}."}, :name clojure.data.avl/nearest, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 14, :method-params ([coll test x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1158, :end-line 1158, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll test x])), :doc "(alpha)\n\n  Equivalent to, but more efficient than, (first (subseq* coll test x)),\n  where subseq* is clojure.core/subseq for test in #{>, >=} and\n  clojure.core/rsubseq for test in #{<, <=}."}, insert {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 309, :column 17, :end-line 309, :end-column 23, :private true, :arglists (quote ([comp node k v found?]))}, :private true, :name clojure.data.avl/insert, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 23, :method-params ([comp node k v found?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 309, :end-line 309, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp node k v found?]))}, AVLSet {:num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection clojure.data.avl/Object cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/ILookup}, :name clojure.data.avl/AVLSet, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 16, :type true, :column 10, :line 955, :record false, :end-line 955, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/ILookup}}, AVLTransientMap {:num-fields 4, :protocols #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name clojure.data.avl/AVLTransientMap, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 25, :type true, :column 10, :line 900, :record false, :end-line 900, :skip-protocol-flag #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, maybe-rebalance! {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 269, :column 17, :end-line 269, :end-column 33, :private true, :arglists (quote ([edit node]))}, :private true, :name clojure.data.avl/maybe-rebalance!, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 33, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 269, :end-line 269, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, rotate-right {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 131, :column 17, :end-line 131, :end-column 29, :private true, :arglists (quote ([node]))}, :private true, :name clojure.data.avl/rotate-right, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 29, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 131, :end-line 131, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, AVLTransientSet {:num-fields 1, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name clojure.data.avl/AVLTransientSet, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 25, :type true, :column 10, :line 1055, :record false, :end-line 1055, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, lookup-nearest {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 182, :column 17, :end-line 182, :end-column 31, :private true, :arglists (quote ([comp node test k]))}, :private true, :name clojure.data.avl/lookup-nearest, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 31, :method-params ([comp node test k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 182, :end-line 182, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp node test k]))}, ->AVLSet {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 955, :column 10, :end-line 955, :end-column 16, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection clojure.data.avl/Object cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/ILookup}, :factory :positional, :arglists (quote ([_meta avl-map _hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection clojure.data.avl/Object cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/ILookup}, :name clojure.data.avl/->AVLSet, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 16, :method-params ([_meta avl-map _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 955, :end-line 955, :max-fixed-arity 3, :fn-var true, :arglists (quote ([_meta avl-map _hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/ILookup}}, ->AVLNode {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 20, :column 10, :end-line 20, :end-column 17, :protocols #{clojure.data.avl/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit key val left right height rank]))}, :protocols #{clojure.data.avl/Object}, :name clojure.data.avl/->AVLNode, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 17, :method-params ([edit key val left right height rank]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 20, :end-line 20, :max-fixed-arity 7, :fn-var true, :arglists (quote ([edit key val left right height rank])), :skip-protocol-flag nil}, lookup {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 173, :column 17, :end-line 173, :end-column 23, :private true, :arglists (quote ([comp node k]))}, :private true, :name clojure.data.avl/lookup, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 23, :method-params ([comp node k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 173, :end-line 173, :max-fixed-arity 3, :fn-var true, :arglists (quote ([comp node k]))}, sorted-set {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 1139, :column 7, :end-line 1139, :end-column 17, :arglists (quote ([& keys])), :doc "Returns a new sorted set with supplied keys.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}}, :name clojure.data.avl/sorted-set, :variadic true, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}, :method-params [(keys)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1139, :end-line 1139, :max-fixed-arity 0, :fn-var true, :arglists ([& keys]), :doc "Returns a new sorted set with supplied keys."}, rank {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 213, :column 17, :end-line 213, :end-column 21, :private true, :arglists (quote ([comp node k]))}, :private true, :name clojure.data.avl/rank, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 21, :method-params ([comp node k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 213, :end-line 213, :max-fixed-arity 3, :fn-var true, :arglists (quote ([comp node k]))}, avl-map-kv-reduce {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 676, :column 17, :end-line 676, :end-column 34, :private true, :arglists (quote ([node f init]))}, :private true, :name clojure.data.avl/avl-map-kv-reduce, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 34, :method-params ([node f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 676, :end-line 676, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node f init]))}, get-rightmost {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 381, :column 17, :end-line 381, :end-column 30, :private true, :arglists (quote ([node]))}, :private true, :name clojure.data.avl/get-rightmost, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 30, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 381, :end-line 381, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, split-at {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 1196, :column 7, :end-line 1196, :end-column 15, :arglists (quote ([n coll])), :doc "(alpha)\n\n  Equivalent to, but more efficient than,\n  [(into (empty coll) (take n coll))\n   (into (empty coll) (drop n coll))]."}, :name clojure.data.avl/split-at, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 15, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1196, :end-line 1196, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "(alpha)\n\n  Equivalent to, but more efficient than,\n  [(into (empty coll) (take n coll))\n   (into (empty coll) (drop n coll))]."}, delete {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 423, :column 17, :end-line 423, :end-column 23, :private true, :arglists (quote ([comp node k found?]))}, :private true, :name clojure.data.avl/delete, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 23, :method-params ([comp node k found?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 423, :end-line 423, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp node k found?]))}, AVLNode {:num-fields 7, :protocols #{clojure.data.avl/Object}, :name clojure.data.avl/AVLNode, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 17, :type true, :column 10, :line 20, :record false, :end-line 20, :skip-protocol-flag nil}, insert! {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 349, :column 17, :end-line 349, :end-column 24, :private true, :arglists (quote ([edit comp node k v found?]))}, :private true, :name clojure.data.avl/insert!, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 24, :method-params ([edit comp node k v found?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 349, :end-line 349, :max-fixed-arity 6, :fn-var true, :arglists (quote ([edit comp node k v found?]))}, sorted-set-by {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 1144, :column 7, :end-line 1144, :end-column 20, :arglists (quote ([comparator & keys])), :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}}, :name clojure.data.avl/sorted-set-by, :variadic true, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}, :method-params [(comparator keys)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1144, :end-line 1144, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keys]), :doc "Returns a new sorted set with supplied keys, using the supplied comparator."}, empty-set {:name clojure.data.avl/empty-set, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :line 1094, :column 1, :end-line 1094, :end-column 25, :private true, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 1094, :column 16, :end-line 1094, :end-column 25, :private true}}, create-seq {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 673, :column 17, :end-line 673, :end-column 27, :private true, :arglists (quote ([node ascending? cnt]))}, :private true, :name clojure.data.avl/create-seq, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 27, :method-params ([node ascending? cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 673, :end-line 673, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node ascending? cnt]))}, empty-map {:name clojure.data.avl/empty-map, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :line 1092, :column 1, :end-line 1092, :end-column 25, :private true, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 1092, :column 16, :end-line 1092, :end-column 25, :private true}}, split {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 600, :column 17, :end-line 600, :end-column 22, :private true, :arglists (quote ([comp node k]))}, :private true, :name clojure.data.avl/split, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 22, :method-params ([comp node k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 600, :end-line 600, :max-fixed-arity 3, :fn-var true, :arglists (quote ([comp node k]))}, delete-rightmost {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 386, :column 17, :end-line 386, :end-column 33, :private true, :arglists (quote ([node]))}, :private true, :name clojure.data.avl/delete-rightmost, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 33, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 386, :end-line 386, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, delete-rightmost! {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 398, :column 17, :end-line 398, :end-column 34, :private true, :arglists (quote ([edit node]))}, :private true, :name clojure.data.avl/delete-rightmost!, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 34, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 398, :end-line 398, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, ->AVLMap {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 757, :column 10, :end-line 757, :end-column 16, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection clojure.data.avl/Object cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([comp tree cnt _meta _hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection clojure.data.avl/Object cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name clojure.data.avl/->AVLMap, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 16, :method-params ([comp tree cnt _meta _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 757, :end-line 757, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree cnt _meta _hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, delete! {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 472, :column 17, :end-line 472, :end-column 24, :private true, :arglists (quote ([edit comp node k found?]))}, :private true, :name clojure.data.avl/delete!, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 24, :method-params ([edit comp node k found?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 472, :end-line 472, :max-fixed-arity 5, :fn-var true, :arglists (quote ([edit comp node k found?]))}, sorted-map-by {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 1124, :column 7, :end-line 1124, :end-column 20, :arglists (quote ([comparator & keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}}, :name clojure.data.avl/sorted-map-by, :variadic true, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}, :method-params [(comparator keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1124, :end-line 1124, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator."}, ->AVLMapSeq {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 690, :column 10, :end-line 690, :end-column 19, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection clojure.data.avl/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([_meta stack ascending? cnt _hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection clojure.data.avl/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name clojure.data.avl/->AVLMapSeq, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 19, :method-params ([_meta stack ascending? cnt _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 690, :end-line 690, :max-fixed-arity 5, :fn-var true, :arglists (quote ([_meta stack ascending? cnt _hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, subrange {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 1210, :column 7, :end-line 1210, :end-column 15, :arglists (quote ([coll test limit] [coll start-test start end-test end])), :doc "(alpha)\n\n  Returns an AVL collection comprising the entries of coll between\n  start and end (in the sense determined by coll's comparator) in\n  logarithmic time. Whether the endpoints are themselves included in\n  the returned collection depends on the provided tests; start-test\n  must be either > or >=, end-test must be either < or <=.\n\n  When passed a single test and limit, subrange infers the other end\n  of the range from the test: > / >= mean to include items up to the\n  end of coll, < / <= mean to include items taken from the beginning\n  of coll.\n\n  (subrange >= start <= end) is equivalent to, but more efficient\n  than, (into (empty coll) (subseq coll >= start <= end).", :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([coll test limit] [coll start-test start end-test end]), :arglists ([coll test limit] [coll start-test start end-test end]), :arglists-meta (nil nil)}}, :name clojure.data.avl/subrange, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([coll test limit] [coll start-test start end-test end]), :arglists ([coll test limit] [coll start-test start end-test end]), :arglists-meta (nil nil)}, :method-params ([coll test limit] [coll start-test start end-test end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1210, :end-line 1210, :max-fixed-arity 5, :fn-var true, :arglists ([coll test limit] [coll start-test start end-test end]), :doc "(alpha)\n\n  Returns an AVL collection comprising the entries of coll between\n  start and end (in the sense determined by coll's comparator) in\n  logarithmic time. Whether the endpoints are themselves included in\n  the returned collection depends on the provided tests; start-test\n  must be either > or >=, end-test must be either < or <=.\n\n  When passed a single test and limit, subrange infers the other end\n  of the range from the test: > / >= mean to include items up to the\n  end of coll, < / <= mean to include items taken from the beginning\n  of coll.\n\n  (subrange >= start <= end) is equivalent to, but more efficient\n  than, (into (empty coll) (subseq coll >= start <= end)."}, sorted-map {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 1111, :column 7, :end-line 1111, :end-column 17, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new AVL map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name clojure.data.avl/sorted-map, :variadic true, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1111, :end-line 1111, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new AVL map with supplied mappings."}, ->AVLTransientMap {:protocol-inline nil, :meta {:file "C:\\Users\\PedroIago\\Documents\\GitHub\\pong\\resources\\public\\js\\clojure\\data\\avl.cljs", :line 900, :column 10, :end-line 900, :end-column 25, :protocols #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([edit comp tree cnt]))}, :protocols #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name clojure.data.avl/->AVLTransientMap, :variadic false, :file "resources\\public\\js\\clojure\\data\\avl.cljs", :end-column 25, :method-params ([edit comp tree cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 900, :end-line 900, :max-fixed-arity 4, :fn-var true, :arglists (quote ([edit comp tree cnt])), :skip-protocol-flag #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}}, :require-macros nil, :cljs.analyzer/constants {:seen #{height comp :else left transient-avl-map _meta tree key avl-map rank edit val ascending? cnt _hash :mutable stack right}, :order [edit key :mutable val left right height rank :else _meta stack ascending? cnt _hash comp tree avl-map transient-avl-map]}, :doc "An implementation of persistent sorted maps and sets based on AVL\n  trees which can be used as drop-in replacements for Clojure's\n  built-in sorted maps and sets based on red-black trees. Apart from\n  the standard sorted collection API, the provided map and set types\n  support the transients API and several additional logarithmic time\n  operations: rank queries via clojure.core/nth (select element by\n  rank) and clojure.data.avl/rank-of (discover rank of element),\n  \"nearest key\" lookups via clojure.data.avl/nearest, splits by key\n  and index via clojure.data.avl/split-key and\n  clojure.data.avl/split-at, respectively, and subsets/submaps using\n  clojure.data.avl/subrange."}